#!/usr/bin/env python
# -*- coding:utf-8 -*- 


##############################################################################
## license :
##============================================================================
##
## File :        LinacData.py
## 
## Project :     LinacData
##
## This file is part of Tango device class.
## 
## Tango is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
## 
## Tango is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
## 
## You should have received a copy of the GNU General Public License
## along with Tango.  If not, see <http://www.gnu.org/licenses/>.
## 
##
## $Author :      sblanch$
##
## $Revision :    $
##
## $Date :        $
##
## $HeadUrl :     $
##============================================================================
##            This file is generated by POGO
##    (Program Obviously used to Generate tango Object)
##
##        (c) - Software Engineering Group - ESRF
##############################################################################
"""Device Server to control the Alba's Linac manufactured by Thales."""

__all__ = ["LinacData", "LinacDataClass", "main"]

__docformat__ = 'restructuredtext'

import PyTango
import sys
# Add additional import
#----- PROTECTED REGION ID(LinacData.additionnal_import) ENABLED START -----#
import time
import tcpblock
import socket
from ctypes import c_uint16, c_uint8, c_float, c_int16
from numpy import uint16,uint8,float32,int16
import traceback
from copy import copy
from types import StringType
import functools
import pprint
import threading
import struct
import fcntl

from constants import *

class release:
    author = 'Lothar Krause <lkrause@cells.es> &'\
             ' Sergi Blanch-Torne <sblanch@cells.es>'
    hexversion = 0x020203
    __str__ = lambda self: hex(hexversion)

if False:
  TYPE_MAP = {
      PyTango.DevUChar : c_uint8,
      PyTango.DevShort : c_int16,
      PyTango.DevFloat : c_float,
      PyTango.DevDouble: c_float,
  }
else:
  TYPE_MAP = {
      PyTango.DevUChar : ('B',1),
      PyTango.DevShort : ('h',2),
      PyTango.DevFloat : ('f',4),
      PyTango.DevDouble: ('f',4), # the PLCs only use floats of 4 bytes
  }


def john(sls):
    '''used to encode the messages shown for each state code
    '''
    if type(sls) == dict:
        return '\n'+''.join('%d:%s\n'%(t,sls[t]) for t in sls.keys())
    else:
        return '\n'+''.join('%d:%s\n' % t for t in enumerate(sls))

class LinacException(Exception):
    pass

def CommandExc(f):
    '''Decorates commands so that the exception is logged and also raised.
    '''

    def g(self, *args, **kwargs):
        inst = self #< for pychecker

        try:
            return f(inst, *args, **kwargs)

        except LinacException:
            raise

        except Exception, exc:
            traceback.print_exc(exc)
            self._trace = traceback.format_exc(exc)
            raise

    functools.update_wrapper(g,f)
    return g

def AttrExc(f):
    '''Decorates commands so that the exception is logged and also raised.
    '''

    def g(self, attr, *args, **kwargs):
        inst = self #< for pychecker

        try:
            return f(inst, attr, *args, **kwargs)

        except LinacException:
            raise

        except Exception, exc:
            traceback.print_exc(exc)
            self._trace = traceback.format_exc(exc)
            raise

    functools.update_wrapper(g,f)
    return g

def latin1(x):
  return x.decode('utf-8').replace(u'\u2070', u'\u00b0').\
      replace(u'\u03bc',u'\u00b5').encode('latin1')

#---- Circular buffer to store last read values and based on it average define
#     the attribute quality
import numpy as np
DEFAULT_SIZE=10
class CircularBuffer(object):
    def __init__(self,buffer,maxlen=DEFAULT_SIZE):
        self.__maxlen=maxlen
        if type(buffer) == list:
            self.__buffer = np.array(buffer[-self.__maxlen:])
            if self.__buffer.ndim > 1:
                raise BufferError("Not supported multi-dimensions")
        else:
            raise BufferError("Input buffer invalid")
    def __str__(self):
        return self.__buffer.__str__()
    def __repr__(self):
        return self.__buffer.__repr__()
    def append(self,newElement):
        if len(self.__buffer) > 0:
            self.__buffer = np.append(self.__buffer,
                                      newElement)[-self.__maxlen:]
        else:
            self.__buffer = np.array([newElement])
    @property
    def mean(self):
        if len(self.__buffer)>0:
            return self.__buffer.mean()
        else:
            return float('NaN')
    @property
    def std(self):
        if len(self.__buffer)>0:
            return self.__buffer.std()
        else:
            return float('NaN')
    @property
    def max(self):
        if len(self.__buffer)>0:
            return self.__buffer.max()
        else:
            return float('NaN')
    @property
    def min(self):
        if len(self.__buffer)>0:
            return self.__buffer.min()
        else:
            return float('NaN')
    @property
    def value(self):
        if len(self.__buffer)>0:
            return self.__buffer[-1]
        else:
            return None
    @property
    def array(self):
        if len(self.__buffer)>0:
            return self.__buffer
        else:
            return np.array([])
    

class AttrList(object):
    '''Manages dynamic attributes and contains methods for conveniently adding
       attributes to a running TANGO device.
    '''

    def __init__(self, device):
        self.impl = device
        self.alist = list()
        self.locals_ = { }

        self.globals_ = globals()
        self.globals_.update({
            'DEVICE' : self.impl,
            'LIST' : self,
            'Attr' : self.add_AttrAddr,
            'AttrAddr' : self.add_AttrAddr,#It is the same that Attr()
            'AttrBit' : self.add_AttrAddrBit,
            'GrpBit' : self.add_AttrGrpBit,
            'AttrLogic':self.add_AttrLogic,
            'AttrRampeable' : self.add_AttrRampeable,
            'AttrLock_ST' : self.add_AttrLock_ST,#Thales calls this CommStatus
            'AttrLocking' : self.add_AttrLocking,
            'AttrHeartBeat' : self.add_AttrHeartBeat,
            'AttrPLC' : self.add_AttrPLC,
            'john' : john,
        })

    def add_Attr(self, name, T, rfun=None, wfun=None, l=None, d=None,
                 min=None, max=None, unit=None,format=None,memorized=False):
        if wfun:
            attr = PyTango.Attr(name, T, PyTango.READ_WRITE)
        else:
            attr = PyTango.Attr(name, T, PyTango.READ)

        aprop = PyTango.UserDefaultAttrProp()
        if unit is not None: aprop.set_unit(latin1(unit))
        if min is not None: aprop.set_min_value(str(min))
        if max is not None: aprop.set_max_value(str(max))
        if format is not None:
            attrStruct = self.impl._getAttrStruct(name)
            attrStruct['format'] = str(format) 
            aprop.set_format(latin1(format))
        if d is not None: aprop.set_description(latin1(d))
        if l is not None: aprop.set_label(latin1(l))
        if memorized: attr.set_memorized_init(True)
        attr.set_default_properties(aprop)

        rfun = AttrExc(rfun)
        if wfun:
            wfun = AttrExc(wfun)

        self.impl.add_attribute(attr, r_meth=rfun, w_meth=wfun)
        if self.impl._plcAttrs.has_key(name) and \
           self.impl._plcAttrs[name].has_key(EVENTS):
            self.impl.set_change_event(name,True,False)
        elif self.impl._internalAttrs.has_key(name) and \
           self.impl._internalAttrs[name].has_key(EVENTS):
            self.impl.set_change_event(name,True,False)
        self.alist.append(attr)
        return attr

    def __getAttrMethod(self,operation,attrName,
                        isBit=False,rampeable=False,internal=False,
                        isGroup=False,isLogical=False):
        #if exist an specific method
        if hasattr(self.impl,"%s_%s"%(operation,attrName)):
            return getattr(self.impl,"%s_%s"%(operation,attrName))
        #or use the generic method for its type
        elif isBit:
            return getattr(self.impl,"%s_attr_bit"%(operation))
        elif operation == 'write' and rampeable:
            #no sense with read operation
            return getattr(self.impl,"write_attr_with_ramp")
        elif isGroup:
            return getattr(self.impl,'%s_attrGrpBit'%(operation))
        elif internal:
            return getattr(self.impl,"%s_internal_attr"%(operation))
        elif isLogical:
            return getattr(self.impl,"%s_logical_attr"%(operation))
        else:
            return getattr(self.impl,"%s_attr"%(operation))

    def __traceAttrAddr(self,attrName,attrType,
                        readAddr=None,readBit=None,
                        writeAddr=None,writeBit=None,
                        internal=False,internalRO=False):
        #first column is the attrName
        msg = "%30s\t"%("'%s'"%attrName)
        #second, its type
        msg += "%10s\t"%("'%s'"%attrType)
        #Then, if it's read only or read/write
        if not writeAddr == None or internal:
            msg += "   'RW'\t"
        else:
            msg += "'RO'   \t"
        if not readAddr == None:
            if not readBit == None:
                read = "'%s.%s'"%(readAddr,readBit)
            else:
                read = "'%s'"%(readAddr)
            msg += "%6s\t"%(read)
        if not writeAddr == None:
            if not writeBit == None:
                write = "'%s.%s'"%(writeAddr,writeBit)
            else:
                write = "'%s'"%(writeAddr)
            msg += "%6s\t"%(write)
        self.impl.debug_stream(msg)

    def __mapTypes(self,attrType):
        # ugly hack needed for SOLEILs archiving system
        if attrType == PyTango.DevFloat:
            return PyTango.DevDouble
        elif attrType == PyTango.DevUChar:
            return PyTango.DevShort
        else:
            return attrType

    def __prepareAttribute(self,attrName,attrType,
                           readAddr,readBit=None,
                           writeAddr=None,writeBit=None,
                           formula=None):
        self.impl._plcAttrs[attrName] = {READADDR:readAddr}
        if not readBit == None:
            self.impl._plcAttrs[attrName][READBIT] = readBit
        self.impl._plcAttrs[attrName][READVALUE] = None
        self.impl._plcAttrs[attrName][READTIME] = None
        if not writeAddr == None:
            self.impl._plcAttrs[attrName][WRITEADDR] = writeAddr
            self.impl._plcAttrs[attrName][WRITEVALUE] = None
            if not writeBit == None:
                self.impl._plcAttrs[attrName][WRITEBIT] = writeBit
        if attrType in [PyTango.DevString,PyTango.DevBoolean]:
            self.impl._plcAttrs[attrName][TYPE]=attrType
        else:
            self.impl._plcAttrs[attrName][TYPE]=TYPE_MAP[attrType]
        if formula != None:
            self.impl._plcAttrs[attrName][FORMULA] = formula
    def __prepareInternalAttribute(self,attrName,attrType,
                                   memorized=False,isWritable=False,
                                   defaultValue=None):
        self.impl._internalAttrs[attrName] = {}
        self.impl._internalAttrs[attrName][TYPE]=attrType
        if memorized:
            try:
                #next call will use the type on the structure _internalAttrs
                memorized = self.impl.recoverDynMemorized(attrName)
                self.impl._internalAttrs[attrName][READVALUE] = memorized
            except:
                self.impl.warn_stream("Cannot recover a memorised value for %s"
                                      %attrName)
                self.impl._internalAttrs[attrName][READVALUE] = defaultValue
        else:
            self.impl._internalAttrs[attrName][READVALUE] = defaultValue
        if isWritable:
            self.impl._internalAttrs[attrName][WRITEVALUE] = None
        self.impl._internalAttrs[attrName][READTIME] = None

    def __prepareEvents(self,attrName,eventConfig):
        if not eventConfig == None:
            attrStruct = self.impl._getAttrStruct(attrName)
            attrStruct[EVENTS] = eventConfig
            attrStruct[LASTEVENTQUALITY] = PyTango.AttrQuality.ATTR_VALID
            
    def __prepareAttrWithMeaning(self,attrName,attrType,meanings,qualities,
                                 rfun,wfun,**kwargs):
        '''There are some short integers where the number doesn't mean anything
           by itself. The plcs register description shows a relation between 
           the possible numbers and its meaning.
           These attributes are splitted in two:
           - one with only the number (machine readable: archiver,plots)
           - another string with the number and its meaning (human readable)
        '''
        #first, build the same than has been archived
        attrState = self.add_Attr(attrName,attrType,rfun,wfun,**kwargs)
        #then prepare the human readable attribute
        #- clone the configuration
        statusDescription = copy(self.impl._plcAttrs[attrName])
        statusDescription[MEANINGS] = meanings
        #write feature is useless on this alternative
        if statusDescription.has_key(WRITEADDR):
            statusDescription.pop(WRITEADDR)
        if statusDescription.has_key(WRITEVALUE):
            statusDescription.pop(WRITEVALUE)
        if statusDescription.has_key(WRITEBIT):
            statusDescription.pop(WRITEBIT)
        #those attributes may come with a qualities dictionary also
        if not qualities == None:
            statusDescription[QUALITIES]=qualities
        #finally prepare the name for the alternative attribute
        if attrName.endswith('_ST'):
            attrNameStatus = attrName.replace('_ST','_Status')
        else:
            attrNameStatus = "%s_Status"%(attrName)
        #insert the attribute description in the structure
        self.impl._plcAttrs[attrNameStatus] = statusDescription
        #last step is to build this alternative attribute
        attrStatus = self.add_Attr(attrNameStatus,PyTango.DevString,
                                   rfun,wfun=None,**kwargs)
        return (attrState,attrStatus)
    
    def __prepareAttrWithQualities(self,attrName,attrType,qualities,
                                   rfun,wfun,**kwargs):
        self.impl._plcAttrs[attrName][READVALUE]=CircularBuffer([])
        self.impl._plcAttrs[attrName][QUALITIES] = qualities
        return self.add_Attr(attrName,attrType,rfun,wfun,**kwargs)

    def add_AttrAddr(self,name,T,read_addr=None,write_addr=None,
                       meanings=None,qualities=None,events=None,
                       formula=None,**kwargs):
        #---- FIXME: What this 'isa' parameter?
        rfun = self.__getAttrMethod('read',name)

        if not write_addr is None:
            wfun = self.__getAttrMethod('write',name)
        else:
            wfun = None
        self.__traceAttrAddr(name,T,readAddr=read_addr,writeAddr=write_addr)
        tango_T = self.__mapTypes(T)
        self.__prepareAttribute(name,T,readAddr=read_addr,writeAddr=write_addr,
                                formula=formula)
        self.__prepareEvents(name,events)
        if not meanings == None:
            return self.__prepareAttrWithMeaning(name,tango_T,meanings,
                                                 qualities,
                                                 rfun,wfun,**kwargs)
        elif not qualities == None:
            return self.__prepareAttrWithQualities(name,tango_T,qualities,
                                                   rfun,wfun,**kwargs)
        else:
            return self.add_Attr(name,tango_T,rfun,wfun,**kwargs)

    def add_AttrAddrBit(self,name,read_addr=None,read_bit=0,write_addr=None,
                          write_bit=None,meanings=None,qualities=None,
                          events=None,isRst=False,activeRst_t=None,
                          formula=None,switchDescriptor=None,**kwargs):
        '''This method is a builder of a boolean dynamic attribute, even for RO
           than for RW. There are many optional parameters.
           
           With the meanings argument, moreover the DevBoolean a DevString
           attribute will be also generated (suffixed *_Status) with the same 
           event and qualities configuration if they are, and will have a 
           human readable message from the concatenation of the value and its
           meaning.
           
           There are also boolean attributes with a reset feature, those are
           attributes that can be triggered and after some short period of time
           they are automatically set back. The time with this reset active
           can be generic (and uses ACTIVE_RESET_T from the constants) or can
           be specified for a particular attribute using the activeRst_t.
           
           Another feature implemented for this type of attributes is the 
           formula. That requires a dictionary with keys:
           + 'read' | 'write': they contain an string to be evaluated when 
             value changes like a filter or to avoid an action based on some
             condition.
           For example, this is used to avoid to power up klystrons if there 
           is an interlock, or to switch of the led when an interlock occurs.
           {'read':'VALUE and '\
                       'self._plcAttrs[\'HVPS_ST\'][\'read_value\'] == 9 and '\
                       'self._plcAttrs[\'Pulse_ST\'][\'read_value\'] == 8',
                 'write':'VALUE and '\
                       'self._plcAttrs[\'HVPS_ST\'][\'read_value\'] == 8 and '\
                       'self._plcAttrs[\'Pulse_ST\'][\'read_value\'] == 7'
                },
           
           The latest feature implemented has relation with the rampeable 
           attributes and this is a secondary configuration for the 
           AttrRampeable DevDouble attributes, but in this case the feature 
           to complain is to manage ramping on the booleans that power on and 
           off those elements.
           The ramp itself shall be defined in the DevDouble attribute, the 
           switch attribute only needs to know where to send this when state
           changes.
           The switchDescriptor is a dictionary with keys:
           + ATTR2RAMP: the name of the numerical attribute involved with the
             state transition.
           + WHENON | WHENOFF: keys to differentiate action interval between 
             the two possible state changes.
             - FROM: initial value of the state change ramp
             - TO: final value of the state change ramp
             About those two last keys, they can be both or only one.
        '''

        if write_bit is None:
            write_bit = read_bit

        rfun = self.__getAttrMethod('read',name,isBit=True)

        if not write_addr is None:
            wfun = self.__getAttrMethod('write',name,isBit=True)
        else:
            wfun = None
        self.__traceAttrAddr(name,PyTango.DevBoolean,
                             readAddr=read_addr,readBit=read_bit,
                             writeAddr=write_addr,writeBit=write_bit)
        self.__prepareAttribute(name,PyTango.DevBoolean,
                                readAddr=read_addr,readBit=read_bit,
                                writeAddr=write_addr,writeBit=write_bit,
                                formula=formula)
        if isRst:
            self.impl._plcAttrs[name][ISRESET] = True
            self.impl._plcAttrs[name][RESETTIME] = None
            if activeRst_t != None:
                self.impl._plcAttrs[name][RESETACTIVE] = activeRst_t
        if type(switchDescriptor) == dict:
            self.impl._plcAttrs[name][SWITCHDESCRIPTOR] = switchDescriptor
            self.impl._plcAttrs[name][SWITCHDEST] = None
        self.__prepareEvents(name,events)
        if not meanings == None:
            return self.__prepareAttrWithMeaning(name, PyTango.DevBoolean,
                                                 meanings,qualities,rfun,wfun,
                                                 **kwargs)
        else:
            return self.add_Attr(name,PyTango.DevBoolean,rfun,wfun,**kwargs)

    def add_AttrGrpBit(self,name,read_addr_bit_pairs=[],
                       write_addr_bit_pairs=[],meanings=None,qualities=None,
                       events=None,**kwargs):
        '''An special type of attribute where, given a set of bits by the pair
           [reg,bit] this attribute can operate all of them as one.
           That is, the read value is True if _all_ are true.
                    the write value, is applied to _all_ of them
                    (almost) at the same time.
        '''
        rfun = self.__getAttrMethod('read',name,isGroup=True)
        if len(write_addr_bit_pairs) > 0:
            wfun = self.__getAttrMethod('write',name,isGroup=True)
            writable = True
        else:
            wfun = None
        self.__traceAttrAddr(name,PyTango.DevBoolean,internal=True)
        self.__prepareInternalAttribute(name,PyTango.DevBoolean,
                                        isWritable=writable)
        self.__prepareEvents(name,events)
        attrDescr = self.impl._internalAttrs[name]
        attrDescr['read_set'] = read_addr_bit_pairs
        attrDescr['write_set'] = write_addr_bit_pairs
        newInternalAttr = self.add_Attr(name,PyTango.DevBoolean,
                                        rfun,wfun,**kwargs)

    def add_AttrLogic(self,name,logic,l,d,events=None,
                      operator='and',inverted=False):
        '''Internal type of attribute made to evaluate a logical formula with 
           other attributes owned by the device with a boolean result.
        '''
        rfun = self.__getAttrMethod('read',name,isLogical=True)
        wfun = None #this kind can only be ReadOnly
        self.__traceAttrAddr(name,PyTango.DevBoolean,internalRO=True)
        self.__prepareInternalAttribute(name,PyTango.DevBoolean)
        self.__prepareEvents(name,events)
        self.impl._internalAttrs[name][LOGIC]=logic
        self.impl._internalAttrs[name][OPERATOR]=operator
        self.impl._internalAttrs[name][INVERTED]=inverted
        return self.add_Attr(name,PyTango.DevBoolean,rfun,wfun,l)

    def add_AttrRampeable(self,name,T,read_addr,write_addr,l,unit,
                          rampsDescriptor,
                          events=None,qualities=None,**kwargs):
        '''Given 2 plc memory positions (for read and write), with this method
           build a RW attribute that looks like the other RWs but it includes 
           ramping features.
           - rampsDescriptor is a dictionary with two main keys:
             + ASCENDING | DESCENDING: Each of these keys contain a 
               dictionary in side describing the behaviour of the ramp 
               ('+' mandatory keys, '-' optional keys):
               + STEP: value added/subtracted on each step.
               + STEPTIME: seconds until next step.
               - THRESHOLD: initial value from where start ramping.
               - SWITCH: attribute to monitor if it has switched off
           Those keys will generate attributes called '$name_$key' as memorised
           to allow the user to adapt the behaviour depending on configuration.
           
           About the threshold, it's a request from the user to have, it 
           klystronHV, to not apply the ramp between 0 to N and after, if it's
           above, ramp it to the setpoint. Also the request of the user is to 
           only do this ramp in the increasing way and decrease goes direct.
           Example:
           - rampsDescriptor = {ASCENDING:
                                   {STEP:0.5,#kV
                                    STEPTIME:1,#s
                                    THRESHOLD:20,#kV
                                    SWITCH:'HVPS_ONC'
                                   }}

           Another request for the Filament voltage is a descending ramp in
           similar characteristics than klystrons, but also: once commanded a 
           power off, delay it doing a ramps to 0. This second request will
           be managed from the boolean that does this on/off transition using
           AttrAddrBit() builder together with a switchDescriptor dictionary.
           Example:
           - rampsDescriptor = {DESCENDING:
                                   {STEP:1,#kV
                                    STEPTIME:1,#s
                                    THRESHOLD:-50,#kV
                                    SWITCH:'GUN_HV_ONC'
                                   },
                                ASCENDING:
                                   {STEP:5,#kV
                                    STEPTIME:0.5,#s
                                    THRESHOLD:-90,#kV
                                    SWITCH:'GUN_HV_ONC'
                                   }}
        '''
        rfun = self.__getAttrMethod('read',name)
        wfun = self.__getAttrMethod('write',name,rampeable=True)
        self.__traceAttrAddr(name,T,readAddr=read_addr,writeAddr=write_addr)
        tango_T = self.__mapTypes(T)
        self.__prepareAttribute(name,T,readAddr=read_addr,writeAddr=write_addr)
        self.__prepareEvents(name,events)
        if not qualities == None:
            rampeableAttr = self.__prepareAttrWithQualities(name,tango_T,
                                                           qualities,rfun,wfun,
                                                            **kwargs)
        else:
            rampeableAttr = self.add_Attr(name,tango_T,rfun,wfun,**kwargs)
        #until here, it's not different than another attribute
        #Next is specific for rampeable attributes
        self.impl._plcAttrs[name][RAMP] = rampsDescriptor
        self.impl._plcAttrs[name][RAMPDEST] = None
        for rampDirection in rampsDescriptor.keys():
            if not rampDirection in [ASCENDING,DESCENDING]:
                self.impl.error_stream("In attribute %s, the ramp direction "\
                                       "%s has been not recognised."
                                       %(name,rampDirection))
            else:
                rampAttributes = []
                newAttr = self._buildInternalAttr4RampEnable(name,l)
                if newAttr != None:
                    rampAttributes.append(newAttr)
                for subAttrName in rampsDescriptor[rampDirection].keys():
                    if subAttrName in [STEP,STEPTIME,THRESHOLD]:
                        if subAttrName == STEPTIME:
                            subAttrUnit = 'seconds'
                        else:
                            subAttrUnit = unit
                        defaultValue = rampsDescriptor[rampDirection]\
                                                                  [subAttrName]
                        newAttr = self._buildInternalAttr4Ramping(\
                                                        name+'_'+rampDirection,
                                                     subAttrName,l,subAttrUnit,
                                                     defaultValue)
                        if newAttr != None:
                            rampAttributes.append(newAttr)
#FIXME: this has to be moved out, because it will be an special boolean attr
#                    elif subAttrName in [SWITCH]:
#                        switcher = rampsDescriptor[rampDirection][SWITCH]
                        #The attribute mandatory keyword (even the switch is 
                        #optional itself) doesn't generates an auxiliar 
                        #internal attribute; but need to tag this refered 
                        #attribute to 'report' when it changes.
#                        if switcher.has_key(WHENOFF):
#                            defaultValue = switcher[WHENOFF]
#                            newAttr = self._buildInternalAttr4Ramping(\
#                                                        name+'_'+rampDirection,
#                                                              WHENOFF,l,unit,
#                                                              defaultValue)
#                            if newAttr != None:
#                                rampAttributes.append(newAttr)
        rampAttributes.insert(0,rampeableAttr)
        return tuple(rampAttributes)

    def _buildInternalAttr4Ramping(self,baseName,suffix,baseLabel,unit,
                                   defaultValue):
        name = baseName+'_'+suffix
        try:
            rfun = self.__getAttrMethod('read',name,internal=True)
            wfun = self.__getAttrMethod('write',name,internal=True)
            self.__prepareInternalAttribute(name,PyTango.DevDouble,
                                            isWritable=True,memorized=True,
                                            defaultValue=defaultValue)
            newInternalAttr = self.add_Attr(name,PyTango.DevDouble,rfun,wfun,
                                            l=baseLabel+' '+suffix,
                                            min=0,#strictly positive #?max=1,
                                            unit=unit,
                                            format='%4.1f',
                                            memorized=True)
            self.__traceAttrAddr(name,'DevDouble',internal=True)
            return newInternalAttr
        except Exception,e:
            self.impl.error_stream("%30s\tException:%s"%(name,e))
            return None
        
    def _buildInternalAttr4RampEnable(self,baseName,baseLabel):
        name = baseName+'_'+RAMPENABLE
        try:
            rfun = self.__getAttrMethod('read',name,internal=True)
            wfun = self.__getAttrMethod('write',name,internal=True)
            self.__prepareInternalAttribute(name,PyTango.DevBoolean,
                                            memorized=True,isWritable=True,
                                            defaultValue=True)
            rampEnable = self.add_Attr(name,PyTango.DevBoolean,rfun,wfun,
                                       l=baseLabel+' ramp enable',
                                       memorized=True)
            self.__traceAttrAddr(name,'DevBoolean',internal=True)
            return rampEnable
        except Exception,e:
            self.impl.error_stream("%30s\tException:%s"%(name,e))
            return None

    def add_AttrLock_ST(self, read_addr):
        COMM_STATUS = {0:'unlocked',1:'local',2:'remote'}
        COMM_QUALITIES = {0:PyTango.AttrQuality.ATTR_ALARM,
                          1:PyTango.AttrQuality.ATTR_VALID,
                          2:PyTango.AttrQuality.ATTR_WARNING}
        plc_name = self.impl.get_name().split('/')[-1]
        desc = 'lock status %s' % plc_name
        #---- This attr was a number but for the user what shows the 
        #     information is an string
        self.impl.lock_ST = read_addr
        if hasattr(self.impl,'read_db') and self.impl.read_db != None:
            self.impl.read_db.setChecker(self.impl.lock_ST,
                                         ['\x00','\x01','\x02'])
        LockAttrs = self.add_AttrAddr('Lock_ST',PyTango.DevUChar,read_addr,
                                     l=desc,d=desc+john(COMM_STATUS),
                                     meanings=COMM_STATUS,
                                     qualities=COMM_QUALITIES)
        #This UChar is to know what to read from the plc, the AttrAddr, because
        #it has an enumerate, will set this attr as string
        self.impl.set_change_event('Lock_ST', True, False)
        self.impl.set_change_event('Lock_Status', True, False)
        return LockAttrs

    def add_AttrLocking(self, read_addr, read_bit, write_addr, write_bit):
        desc = 'True when attempting to obtain write lock'
        new_attr = self.add_AttrAddrBit('Locking',read_addr,read_bit,
                                        write_addr,write_bit,d=desc)
        locking_attr = self.impl.get_device_attr().get_attr_by_name('Locking')
        self.impl.Locking = locking_attr
        locking_attr.set_write_value(False)
        self.impl.locking_raddr = read_addr
        self.impl.locking_rbit = read_bit
        #TODO: adding this checker, it works worst
        #if hasattr(self.impl,'read_db') and self.impl.read_db != None:
        #    self.impl.read_db.setChecker(self.impl.locking_raddr,
        #                                 ['\x00','\x01'])
        self.impl.locking_waddr = write_addr
        self.impl.locking_wbit = write_bit
        #TODO: adding this checker, it works worst
        #if hasattr(self.impl,'read_db') and self.impl.read_db != None:
        #    self.impl.read_db.setChecker(self.impl.locking_waddr,
        #                                 ['\x00','\x01'])
        self.impl.set_change_event('Locking', True, False)
        return new_attr

    def add_AttrHeartBeat(self, read_addr, read_bit=0):
        self.impl.heartbeat_addr = read_addr
        desc = 'cadence bit going from True to False when PLC is okay'
        attr = self.add_AttrAddrBit('HeartBeat',read_addr, read_bit, d=desc)
        self.impl.set_change_event('HeartBeat', True, False)
        return attr


    def add_AttrPLC(self,heart,lockst,read_lockingAddr,read_lockingBit,
                     write_lockingAddr,write_lockingBit):
        heartbeat = self.add_AttrHeartBeat(heart)
        lockState,lockStatus = self.add_AttrLock_ST(lockst)
        locking = self.add_AttrLocking(read_lockingAddr,read_lockingBit,
                                       write_lockingAddr,write_lockingBit)
        return (heartbeat,lockState,lockStatus,locking)

    def remove_all(self):
        for attr in self.alist:
            try:
                self.impl.remove_attribute(attr.get_name())
            except ValueError,exc:
                self.impl.debug_stream(attr.get_name()+': '+str(exc))

    def parse_file(self,  fname):
        msg = "%30s\t%10s\t%5s\t%6s\t%6s"\
               %("'attrName'","'Type'","'RO/RW'","'read'","'write'")
        self.impl.debug_stream( msg)
        try:
            execfile(fname, self.globals_, self.locals_)
        except IOError, io:
            raise LinacException(io)
        except Exception,e:
            self.impl.debug_stream("AttrList.parse_file Exception: %s\n%s"
                                   %(e,traceback.format_exc()))
        self.impl.debug_stream('Parse attrFile done.')
#        self.impl.debug_stream('in the plcAttr dict: %s'
#                               %(pprint.pprint(self.impl._plcAttrs)))
#        self.impl.debug_stream('in the internalAttr dict: %s'
#                               %(self.impl._internalAttrs))

    def parse(self, text):
        exec text in self.globals_, self.locals_

def get_ip(iface = 'eth0'):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sockfd = sock.fileno()
    SIOCGIFADDR = 0x8915
    ifreq = struct.pack('16sH14s', iface, socket.AF_INET, '\x00'*14)
    try:
        res = fcntl.ioctl(sockfd, SIOCGIFADDR, ifreq)
    except:
        return None
    ip = struct.unpack('16sH2x4s8x', res)[2]
    return socket.inet_ntoa(ip)

#----- PROTECTED REGION END -----#    //    LinacData.additionnal_import

## Device States Description
## INIT : The device is being initialised.
## ON : PLC communication normal
## ALARM : Transient issue
## FAULT : Unrecoverable issue
## UNKNOWN : No connection with the PLC, no state information

class LinacData(PyTango.Device_4Impl):

        #--------- Add you global variables here --------------------------
        #----- PROTECTED REGION ID(LinacData.global_variables) ENABLED START -----#
        ReadSize = None
        WriteSize = None
        BindAddress = None #deprecated
        LocalAddress = None
        RemoteAddress = None
        IpAddress = None #deprecated
        PlcAddress = None
        Port = None
        LocalPort = None
        RemotePort = None
        # assigned by addAttrLocking
        locking_raddr = None
        locking_rbit = None
        locking_waddr = None
        locking_wbit = None
        lock_ST = None
        Locking = None
        is_lockedByTango = None
        heartbeat_addr = None
        AttrFile = None
        _plcAttrs = {}
        _internalAttrs = {}
        
        disconnect_t = 0
        read_db = None
        _important_logs = []
        _rampThreads = {}
        _switchThreads = {}
        
        _prevMemDump = None
        _prevLockSt = None

        ####
        #---- PLC connectivity area
        def connect(self):
            '''This method is used to build the object that maintain the 
               communications with the assigned PLC.
            '''
            if self.read_db != None:
                return
            self.info_stream('connecting...')
            self.set_status('connecting...')
            try:
                self.read_db = tcpblock.open_datablock(self.PlcAddress,
                                                       self.Port,
                                                       self.ReadSize,
                                                       self.WriteSize,
                                                       self.BindAddress,
                                                       self.info_stream,
                                                       self.debug_stream,
                                                       self.warn_stream,
                                                       self.error_stream,
                                                       self.lock_ST)
                self.info_stream("build the tcpblock, socket %d"
                                  %(self.read_db.sock.fileno()))
                self.write_db = self.read_db
                self.info_stream('connected')
                self.set_state(PyTango.DevState.ON)
                self.set_status('connected')
                return True
            except Exception,e:
                self.error_stream('connection failed exception: %s'
                                  %(traceback.format_exc()))
                self.set_state(PyTango.DevState.FAULT)
                self.set_status(traceback.format_exc())
                return False

        def disconnect(self):
            '''This method closes the connection to the assigned PLC.
            '''
            self.info_stream('disconnecting...')
            self.set_status('disconnecting...')
            self._plcUpdatePeriod = PLC_MAX_UPDATE_PERIOD
            try:
                if self.is_connected():
                    tcpblock.close_datablock(self.read_db,self.warn_stream)
                    self.read_db = None
                if self.get_state()==PyTango.DevState.ON:
                    self.set_state(PyTango.DevState.OFF)
                    self.set_status('not connected')
                return True
            except:
                return False

        def reconnect(self):
            '''
            '''
            if time.time()-self.last_update_time > self.ReconnectWait:
                self.connect()

        def is_connected(self):
            '''Checks if the object that interfaces the communication with 
               the PLC is well made and available.
            '''
            return (not self.read_db is None) and \
                   (not self.read_db.sock is None)

        def has_data_available(self):
            '''Check if there is some usable data give from the PLC.
            '''
            return self.is_connected() and \
                   (len(self.read_db.buf)==self.ReadSize)
        #---- Done PLC connectivity area

        ####
        #---- state/status manager methods
        def set_state(self, newState):
            '''Overload of the superclass method to add event 
               emission functionality.
            '''
            if self.get_state() != newState:
                self.warn_stream("Change state from %s to %s"
                                 %(self.get_state(),newState))
                PyTango.Device_4Impl.set_state(self, newState)
                self.push_change_event('State',newState)
                self.set_status("")

        def set_status(self, newLine2status,important=False):
            '''Overload of the superclass method to add the extra feature of
               the persistent messages added to the status string.
            '''
            #self.debug_stream("In set_status()")
            newStatus = ""#The device is in %s state.\n"%(self.get_state())
            for importantMsg in self._important_logs:
                if len(importantMsg) > 0:
                    newStatus = "%s%s\n"%(newStatus,importantMsg)
            if len(newLine2status) > 0 and \
               not newLine2status in self._important_logs:
                newStatus = "%s%s\n"%(newStatus,newLine2status)
                if important:
                    self._important_logs.append(newLine2status)
            if len(newStatus) == 0:
                newStatus = "The device is in %s state.\n"%(self.get_state())
            oldStatus = self.get_status()
            if newStatus != oldStatus:
                PyTango.Device_4Impl.set_status(self, newStatus)
                self.warn_stream("New status message: %s"
                                  %(repr(self.get_status())))
                self.push_change_event('Status',newStatus)

        def clean_status(self):
            '''With the extra feature of the important logs, this method allows
               to clean all those logs as a clean interlocks method does.
            '''
            self.debug_stream("In clean_status()")
            self._important_logs = []
            self.set_status("")
        #---- done state/status manager methods
        
        ####
        #---- event methods
        def fireEvent(self,attrEventStruct,timestamp=None):
            '''Method with the procedure to emit an event from one existing 
               attribute. Minimal needs are the attribute name and the value
               to emit, but also can be specified the quality and the timestamp
            '''
            if timestamp == None:
                timestamp = time.time()
            if self.__isRstAttr(attrEventStruct[0]):
                self.info_stream("In fireEvent() attribute %s = %s"
                                  %(attrEventStruct[0],attrEventStruct[1]))
            if len(attrEventStruct) == 3: #the quality is specified
                self.push_change_event(attrEventStruct[0],attrEventStruct[1],
                                       timestamp,
                                       attrEventStruct[2])
            else:
                self.push_change_event(attrEventStruct[0],attrEventStruct[1],
                                       timestamp,
                                       PyTango.AttrQuality.ATTR_VALID)
        
        def fireEventsList(self,eventsAttrList,log=False):
            '''Given a set of pair [attr,value] (with an optional third element
               with the quality) emit events for all of them with the same
               timestamp.
            '''
            if log:
                self.debug_stream("In fireEventsList():\n%s"
                                  %(''.join("\t%s\n"%line \
                                            for line in eventsAttrList)))
            timestamp = time.time()
            attrNames = []
            for attrEvent in eventsAttrList:
                try:
                    self.fireEvent(attrEvent,timestamp)
                    attrNames.append(attrEvent[0])
                except Exception,e:
                    self.error_stream("In fireEventsList() Exception with "\
                                      "attribute %s: %s"%(attrEvent[0],e))
        #---- done event methods

        ####
        #---- Read Attr method for dynattrs
        def __applyReadValue(self,attrName,attrValue,timestamp=None):
            '''Hide the internal differences of the stored attribute struct 
               and return the last value read from the PLC for a certain attr.
            '''
            attrStruct = self._getAttrStruct(attrName)
            if timestamp == None:
                timestamp = time.time()
            if type(attrStruct[READVALUE]) == CircularBuffer:
                attrStruct[READVALUE].append(attrValue)
            else:
                attrStruct[READVALUE] = attrValue
            attrStruct[READTIME] = timestamp

        def __applyWriteValue(self,attrName,attrValue):
            '''Hide the internal attribute struct representation and give an 
               interface to set a value to be written.
            '''
            attrStruct = self._getAttrStruct(attrName)
            if attrStruct.has_key(WRITEVALUE):
                attrStruct[WRITEVALUE] = attrValue

        def __buildAttrMeaning(self,attrName,attrValue):
            '''As some (state-like) attributes have a meaning, there is a 
               status-like attribute that reports what the documentation 
               assign to the enumeration.
            '''
            attrStruct = self._getAttrStruct(attrName)
            meanings = attrStruct[MEANINGS]
            if meanings.has_key(attrValue):
                return "%d:%s"%(attrValue,meanings[attrValue])
            else:
                return "%d:unknown"%(attrValue)

        def __buildAttrQuality(self,attrName,attrValue):
            '''Resolve the quality the an specific value has for an attribute.
            '''
            attrStruct = self._getAttrStruct(attrName)
            if attrStruct.has_key(QUALITIES):
                qualities = attrStruct[QUALITIES]
                if self.__checkQuality(attrName,attrValue,ALARM):
                    return PyTango.AttrQuality.ATTR_ALARM
                elif self.__checkQuality(attrName,attrValue,WARNING):
                    return PyTango.AttrQuality.ATTR_WARNING
                elif self.__checkQuality(attrName,attrValue,CHANGING):
                    return PyTango.AttrQuality.ATTR_CHANGING
            return PyTango.AttrQuality.ATTR_VALID

        def __checkQuality(self,attrName,attrValue,qualityInQuery):
            '''Check if this attrName with the give attrValue is with in the 
               threshold of the give quality
            '''
            attrStruct = self._getAttrStruct(attrName)
            qualities = attrStruct[QUALITIES]
            if qualities.has_key(qualityInQuery):
                if type(qualities[qualityInQuery]) == dict:
                    if self.__checkAbsoluteRange(qualities[qualityInQuery],
                                                 attrValue):
                        return True
                    buffer = attrStruct[READVALUE]
                    if self.__checkRelativeRange(qualities[qualityInQuery],
                                                buffer,
                                                attrValue):
                        return True
                    return False
                elif type(qualities[qualityInQuery]) == list:
                    if attrValue in qualities[qualityInQuery]:
                        return True
            return False

        def __checkAbsoluteRange(self,qualityDict,referenceValue):
            '''Check if the a value is with in any of the configured absolute 
               ranges for the specific configuration with in an attribute.
            '''
            if qualityDict.has_key(ABSOLUTE):
                if qualityDict[ABSOLUTE].has_key(ABOVE):
                    above = qualityDict[ABSOLUTE][ABOVE]
                else:
                    above = float('inf')
                if qualityDict[ABSOLUTE].has_key(BELOW):
                    below = qualityDict[ABSOLUTE][BELOW]
                else:
                    below = float('-inf')
#                self.debug_stream("\t%6.3f <= %6.3f <= %6.3f"
#                                 %(below,referenceValue,above))
                if qualityDict[ABSOLUTE].has_key(UNDER) and \
                   qualityDict[ABSOLUTE][UNDER] == True:
                    if above < referenceValue < below:
                        return True
                else:
                    if not below <= referenceValue <= above:
                        return True
            return False
        
        def __checkRelativeRange(self,qualityDict,buffer,referenceValue):
            '''Check if the a value is with in any of the configured relative 
               ranges for the specific configuration with in an attribute.
            '''
            if qualityDict.has_key(RELATIVE) and \
                                                type(buffer) == CircularBuffer:
                if buffer.std >= qualityDict[RELATIVE]:
                    return True
            return False
        
        def _getAttrStruct(self,attrName):
            '''Given an attribute name, return the internal structure that
               defines its behaviour.
            '''
            if self._plcAttrs.has_key(attrName):
                return self._plcAttrs[attrName]
            elif self._internalAttrs.has_key(attrName):
                return self._internalAttrs[attrName]
            return None

        def __solveFormula(self,attrName,VALUE,formula):
            '''Some attributes can have a formula to interpret or modify the
               value given from the PLC to the value reported by the device.
            '''
            result = eval(formula)
            self.debug_stream("%s formula eval(\"%s\") = %s"
                             %(attrName,formula,result))
            return result

        def __setAttrValue(self,attr,attrName,attrType,attrValue,timestamp):
            '''
            '''
            self.debug_stream("__setAttrvalue(%s,%s,%s,%s)"
                              %(attrName,attrType,attrValue,timestamp))
            attrStruct = self._getAttrStruct(attrName)
            self.__applyReadValue(attrName,attrValue,timestamp)
            if attrStruct.has_key(MEANINGS):
                attrMeaning = self.__buildAttrMeaning(attrName,attrValue)
                attrQuality = self.__buildAttrQuality(attrName,attrValue)
                attr.set_value_date_quality(attrMeaning,timestamp,attrQuality)
            elif attrStruct.has_key(QUALITIES):
                attrQuality = self.__buildAttrQuality(attrName,attrValue)
                attr.set_value_date_quality(attrValue,timestamp,attrQuality)
            else:
                attrQuality = PyTango.AttrQuality.ATTR_VALID
                attr.set_value_date_quality(attrValue,timestamp,attrQuality)
            if attrStruct.has_key(WRITEADDR):
                writeAddr = attrStruct[WRITEADDR]
                sp_addr = self.offset_sp+writeAddr
                if attrStruct.has_key(WRITEBIT):
                    writeBit = attrStruct[WRITEBIT]
                    writeValue = self.read_db.bit(sp_addr,writeBit)
                else:
                    writeValue = self.read_db.get(sp_addr,*attrType)
                    if attrStruct.has_key(FORMULA) and \
                       attrStruct[FORMULA].has_key('write'):
                        try:
                            writeValue = self.__solveFormula(attrName,
                                                             writeValue,
                                                attrStruct[FORMULA]['write'])
                        except Exception,e:
                            self.error_stream("Cannot solve formula for the "\
                                              "attribute %s: %s"%(attrName,e))
                    if attrStruct.has_key('format'):
                        try:
                            format = attrStruct['format']
                            writeValue = float(format%writeValue)
                        except Exception,e:
                            self.error_stream("Cannot format value for the "\
                                              "attribute %s: %s"%(attrName,e))
                self.__applyWriteValue(attrName,writeValue)
                try:
                    attr.set_write_value(writeValue)
                except PyTango.DevFailed,e:
                    self.tainted = "%s/%s: failed to set point %s (%s)"\
                                  %(self.get_name(),attrName,writeValue,e)
                    self.error_stream(self.tainted)
            elif attrStruct.has_key(WRITEVALUE):
                try:
                    writeValue = attrStruct[WRITEVALUE]
                    attr.set_write_value(writeValue)
                except PyTango.DevFailed:
                    self.tainted = self.get_name()+'/'+attrName+\
                                  ': failed to set point '+str(writeValue)
                    self.error_stream("On setAttrValue(%s,%s) tainted: %s"
                                      %(attrName,str(attrValue),self.tainted))
                except Exception,e:
                    self.warn_stream("On setAttrValue(%s,%s) Exception: %s"
                                     %(attrName,str(attrValue),e))
        
        @AttrExc
        def read_attr(self, attr):
            '''
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            name = attr.get_name()
            attrStruct = self._getAttrStruct(name)
            attrType = attrStruct[TYPE]
            read_addr = attrStruct[READADDR]
            if attrStruct.has_key(READBIT):
                read_bit = attrStruct[READBIT]
            else:
                read_bit = None
            try:
                if read_bit:
                    read_value = self.read_db.bit(read_addr, read_bit)
                else:
                    read_value = self.read_db.get(read_addr, *attrType)
                    if attrStruct.has_key(FORMULA) and \
                       attrStruct[FORMULA].has_key('read'):
                        read_value = self.__solveFormula(name,read_value,
                                                 attrStruct[FORMULA]['read'])
                read_t = time.time()
            except Exception,e:
                self.error_stream('Trying to read %s/%s and looks to be not '\
                                  'well connected to the plc.'
                                  %(self.get_name(),attr.get_name()))
                self.debug_stream('Exception (%s/%s): %s'
                                  %(self.get_name(),attr.get_name(),e))
            else:
                self.__setAttrValue(attr,name,attrType,read_value,read_t)

        def read_logical_attr(self,attr):
            '''
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            attrName = attr.get_name()
            if self._internalAttrs.has_key(attrName):
                ret = self._evalLogical(attrName)
                read_t = self._internalAttrs[attrName][READTIME]
                self.__setAttrValue(attr,attrName,PyTango.DevBoolean,
                                    ret,read_t)

        def _evalLogical(self,attrName):
            '''
            '''
            logic = self._internalAttrs[attrName][LOGIC]
            #ret = True
            values = []
            for key in logic.keys():
                attrStruct = self._getAttrStruct(attrName)
                try:
                    value = self.__getAttrReadValue(key)
                except Exception,e:
                    #That should never happen, perhaps better raise exception
                    self.error_stream("cannot eval logic attr %s with "\
                                      "the key %s. Exception: %s"
                                      %(attrName,key,e))
                    attrStruct[READTIME] = time.time()
                    return False
                values.append(value in logic[key])
            #self.debug_stream("%s logical values %s"%(attrName,values))
            if attrStruct[OPERATOR] == 'or':
                ret = any(values)
            elif attrStruct[OPERATOR] == 'and':
                ret = all(values)
            attrStruct[READTIME] = time.time()
            #print("time= %s"%(str(self._internalAttrs[attrName][READTIME])))
            if attrStruct[INVERTED]:
                return not ret
            attrStruct[READVALUE] = ret
            return ret

        #FIXME: this method is merged with read_attr(), and once write versions
        #       become also merged, they will be not necessary anymore.
        @AttrExc
        def read_attr_bit(self, attr):
            '''
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            name = attr.get_name()
            attrType = PyTango.DevBoolean
            attrStruct = self._getAttrStruct(name)
            read_addr = attrStruct[READADDR]
            read_bit = attrStruct[READBIT]
            if attrStruct.has_key(WRITEADDR):
                write_addr = attrStruct[WRITEADDR]
                write_bit = attrStruct[WRITEBIT]
            else:
                write_addr = None
                write_bit = None
            try:
                read_value = self.read_db.bit(read_addr, read_bit)
                if attrStruct.has_key(FORMULA) and \
                   attrStruct[FORMULA].has_key('read'):
                    read_value = self.__solveFormula(name,read_value,
                                                 attrStruct[FORMULA]['read'])
                read_t = time.time()
            except Exception,e:
                self.error_stream('Trying to read %s/%s and looks to be not '\
                                  'well connected to the plc.'
                                  %(self.get_name(),attr.get_name()))
                self.debug_stream('Exception (%s/%s): %s'
                                  %(self.get_name(),attr.get_name(),e))
            else:
                self.__setAttrValue(attr,name,attrType,read_value,read_t)

        def read_attrGrpBit(self,attr):
            '''
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            attrName = attr.get_name()
            if self._internalAttrs.has_key(attrName):
                attrStruct = self._getAttrStruct(attrName)
                if attrStruct.has_key('read_set'):
                    read_value = self.__getGrpBitValue(attrName,
                                                       attrStruct['read_set'],
                                                       self.read_db)
                    read_t = time.time()
                    if attrStruct.has_key('write_set'):
                        write_set = attrStruct['write_set']
                        write_value = self.__getGrpBitValue(attrName,
                                                            write_set,
                                                            self.write_db)
                        self.__applyWriteValue(attrName,
                                               attrStruct[WRITEVALUE])
                    self.__setAttrValue(attr,attrName,PyTango.DevBoolean,
                                        read_value,read_t)
                

        def __getGrpBitValue(self,attrName,addrSet,memSegment):
            '''
            '''
            try:
                bitSet = []
                for addr,bit in addrSet:
                    bitSet.append(memSegment.bit(addr,bit))
                if all(bitSet):
                    return True
            except Exception,e:
                self.error_stream("Cannot get the bit group for %s [%s]: %s\n"
                                  %(attrName,str(addrSet),e,
                                    str(self._internalAttrs[attrName])))
            return False

        def read_lock(self):
            '''
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            rbyte = self.read_db.b(self.locking_raddr)
            locker = bool(rbyte & (1 << self.locking_rbit))
#            self.debug_stream("Read Control Lock: rbyte(%d) is %d, locker %d"
#                              %(self.locking_raddr,rbyte,locker))
            return locker

        @AttrExc
        def read_Locking(self, attr):
            '''
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            '''The read of this attribute is a boolean to represent if the 
               control of the plc has been take by tango. This doesn't look
               to correspond exactly with the same meaning of the "Local Lock"
               boolean in the memory map of the plc'''
            #self.debug_stream('reading Locking')
            #attr.set_value(self.is_lockedByTango)
            self.__setAttrValue(attr,attr.get_name(),PyTango.DevBoolean,
                                    self.is_lockedByTango,time.time())
            #attr.set_value(self.read_lock())

        @AttrExc
        def read_Lock_ST(self,attr):
            '''
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            attrName = attr.get_name()
            #self.debug_stream('reading %s'%(attrName))
            read_addr = self._plcAttrs[attrName][READADDR]
            attrType = ('B',1)
            try:
                self.read_lock_ST_attr = self.read_db.get(read_addr, *attrType)
                lockStr,lock_quality = self.convert_Lock_ST()
                if attrName.endswith('_Status'):
                    attr.set_value(lockStr)
                else:
                    attr.set_value(self.read_lock_ST_attr)
                attr.set_quality(lock_quality)
            except Exception,e:
                self.error_stream('Trying to read %s/%s and may not '\
                                  'well connected to the plc.'
                                  %(self.get_name(),attr.get_name()))
                self.debug_stream('Exception (%s/%s): %s'
                                  %(self.get_name(),attr.get_name(),e))
                if attrName.endswith('_Status'):
                    attr.set_value("-1:exception")
                else:
                    attr.set_value(-1)
                attr.set_quality(PyTango.AttrQuality.ATTR_WARNING)

        def convert_Lock_ST(self):
            '''
            '''
            meanings = self._plcAttrs['Lock_Status'][MEANINGS]
            if not meanings.has_key(self.read_lock_ST_attr):
                lock_String = "%d:unknown"%(self.read_lock_ST_attr)
                lock_quality = PyTango.AttrQuality.ATTR_WARNING
            else:
                if self.read_lock_ST_attr == 1:
                    if self._deviceIsInLocal:
                        tag = "%s (Tango)"%(meanings[self.read_lock_ST_attr])
                    elif self._deviceIsInRemote:
                        tag = "%s (Labview)"%(meanings[self.read_lock_ST_attr])
                elif self.read_lock_ST_attr == 2 and self._deviceIsInRemote:
                    tag = "%s (Tango Read Only)"\
                          %(meanings[self.read_lock_ST_attr])
                else:
                    tag = "%s"%(meanings[self.read_lock_ST_attr])
                lock_String = "%d:%s"%(self.read_lock_ST_attr,tag)
                if self._plcAttrs['Lock_Status'].has_key(QUALITIES):
                    qualities = self._plcAttrs['Lock_Status'][QUALITIES]
                    if qualities.has_key(self.read_lock_ST_attr):
                        lock_quality = qualities[self.read_lock_ST_attr]
                    else:
                        lock_quality = PyTango.AttrQuality.ATTR_WARNING
                else:
                    lock_quality = PyTango.AttrQuality.ATTR_VALID
            if (self._deviceIsInLocal and self.read_lock_ST_attr == 1) or \
               (self._deviceIsInRemote and self.read_lock_ST_attr == 2):
                self.lockingChange(True,lock_String)
            else:
                self.lockingChange(False,lock_String)
            #---- FIXME: the numeric scalars are in use by alarms, and cannot 
            #     be changed this way.
            #return (lock_String,lock_quality)
            return (lock_String,lock_quality)

        def lockingChange(self,newLockValue,lock_String):
            '''
            '''
            if self.is_lockedByTango != newLockValue:
                self.is_lockedByTango = newLockValue
                self.fireEventsList([['Locking',self.is_lockedByTango]])

        @AttrExc
        def read_internal_attr(self, attr):
            '''this is referencing to a device attribute that doesn't
                have plc representation
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            try:
                attrName = attr.get_name()
#                self.debug_stream('read_internal_attr(%s)'%(attrName))
                if self._internalAttrs.has_key(attrName):
                    attrStruct = self._getAttrStruct(attrName)
                    if attrStruct.has_key(READVALUE):
                        read_value = attrStruct[READVALUE]
                    if read_value == None:
                        attr.set_value_date_quality(0,time.time(),
                                              PyTango.AttrQuality.ATTR_INVALID)
                    else:
                        #print read_value
                        attr.set_value(read_value)
            except Exception,e:
                self.error_stream("read_internal_attr(%s) Exception %s"
                                  %(attr.get_name(),e))
        #---- Read Attr method for dynattrs

        ####
        #---- Write Attr method for dynattrs
        def prepare_write(self, attr):
            data = []
            '''
            '''
            self.Locking.get_write_value(data)
            val = data[0]
#            if not val:
            if not self.read_lock():
              raise LinacException('first required to set Locking flag on '\
                                   '%s device'%self.get_name())
            if self.tainted:
              raise LinacException('mismatch with '\
                                   'specification:\n'+self.tainted)
            data = []
            attr.get_write_value(data)
            return data[0]

        @AttrExc
        def write_attr(self, attr):
            '''
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            name = attr.get_name()
#            self.debug_stream("write_attr[%s]"%(name))
            attrStruct = self._getAttrStruct(name)
            attrType = attrStruct[TYPE]
            write_addr = attrStruct[WRITEADDR]
            write_value = self.prepare_write(attr)
            if attrStruct.has_key(FORMULA) and \
               attrStruct[FORMULA].has_key('write'):
                write_value = self.__solveFormula(name,write_value,
                                                attrStruct[FORMULA]['write'])
            attrStruct[WRITEVALUE] = write_value
            self.write_db.write(write_addr, write_value, attrType)

        @AttrExc
        def write_attr_bit(self, attr):
            '''
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            name = attr.get_name()
#            self.debug_stream("write_attr_bit[%s]"%(name))
            attrStruct = self._getAttrStruct(name)
            read_addr = attrStruct[READADDR]
            write_addr = attrStruct[WRITEADDR]
            write_bit = attrStruct[WRITEBIT]
            write_value = self.prepare_write(attr)
            if attrStruct.has_key(FORMULA) and \
               attrStruct[FORMULA].has_key('write'):
                formula_value = self.__solveFormula(name,write_value,
                                                attrStruct[FORMULA]['write'])
                self.info_stream("%s received %s formula eval(\"%s\") = %s"
                                 %(name,write_value,
                                   attrStruct[FORMULA]['write'],
                                   formula_value))
                if formula_value != write_value and \
                   attrStruct[FORMULA].has_key('write_not_allowed'):
                    reason = "Write %s not allowed"%write_value
                    description = attrStruct[FORMULA]['write_not_allowed']
                    PyTango.Except.throw_exception(reason,
                                                   description,
                                                   name,
                                                   PyTango.ErrSeverity.WARN)
                else:
                    write_value = formula_value
            if attrStruct.has_key(SWITCHDESCRIPTOR):
                #Depending to the on or off transition keys, this will launch 
                #a thread who will modify the ATTR2RAMP, and when that 
                #finishes the write will be set.
                if self.__stateTransitionNeeded(write_value,
                                                attrStruct[SWITCHDESCRIPTOR]):
                    attrStruct[SWITCHDEST] = write_value
                    self.createSwitchStateThread(name)
                    return
                #The returns are necessary to avoid the write that is set later
                #on this method. But in the final else case it has to continue.
            self.__writeBit(name,read_addr,write_addr,write_bit, write_value)
            attrStruct[WRITEVALUE] = write_value
            self.info_stream("Received write %s (%s)"%(name,write_value))
            if self.__isRstAttr(name) and write_value == True:
                attrStruct[RESETTIME] = time.time()
            #TODO: this has been splitted to a separated method
#            rbyte = self.read_db.b(read_addr)
#            if write_value:
#                # sets bit 'bitno' of b
#                toWrite = rbyte | (int(write_value) << write_bit)
#                #a byte of 0s with a unique 1 in the place to set this 1
#            else:
#                # clears bit 'bitno' of b
#                toWrite = rbyte & (0xFF)^(1<<write_bit)
#                #a byte of 1s with a unique 0 in the place to set this 0
#            self.write_db.write(write_addr,toWrite,TYPE_MAP[PyTango.DevUChar])
#            reRead = self.read_db.b(read_addr)
#            self.debug_stream("Writing %s boolean to %6s (%d.%d) byte was "\
#                             "%s; write %s; now %s"
#                             %(name,write_value,write_addr,write_bit,
#                               bin(rbyte),bin(toWrite),bin(reRead)))

        def __stateTransitionNeeded(self,value,descriptor):
            if self.__stateTransitionToOn(value,descriptor):
                return True
            elif self.__stateTransitionToOff(value,descriptor):
                return True
            return False
        
        def __stateTransitionToOn(self,value,descriptor):
            if value == True and descriptor.has_key(WHENON):
                return True
            return False
        def __stateTransitionToOff(self,value,descriptor):
            if value == False and descriptor.has_key(WHENOFF):
                return True
            return False

        def __writeBit(self,name,read_addr,write_addr,write_bit,write_value):
            '''
            '''
            rbyte = self.read_db.b(read_addr)
            attrStruct = self._getAttrStruct(name)
            if write_value:
                # sets bit 'bitno' of b
                toWrite = rbyte | (int(1)<<write_bit)
                #a byte of 0s with a unique 1 in the place to set this 1
            else:
                # clears bit 'bitno' of b
                toWrite = rbyte & ((0xFF)^(1<<write_bit))
                #a byte of 1s with a unique 0 in the place to set this 0
            self.write_db.write(write_addr, toWrite,TYPE_MAP[PyTango.DevUChar])
            reRead = self.read_db.b(read_addr)
            self.debug_stream("Writing %s boolean to %6s (%d.%d) byte was "\
                             "%s; write %s; now %s"
                             %(name,write_value,write_addr,write_bit,
                               bin(rbyte),bin(toWrite),bin(reRead)))

        def write_attrGrpBit(self,attr):
            '''
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            attrName = attr.get_name()
            if self._internalAttrs.has_key(attrName):
                attrDescr = self._internalAttrs[attrName]
                if attrDescr.has_key('write_set'):
                    writeValue = self.prepare_write(attr)
                    self.__setGrpBitValue(attrDescr['write_set'],
                                          self.write_db,writeValue)

        def __setGrpBitValue(self,addrSet,memSegment,value):
            '''
            '''
            try:
                for addr,bit in addrSet:
                    rbyte = self.read_db.b(self.offset_sp+addr)
                    if value:
                        toWrite = rbyte | (int(value)<<bit)
                    else:
                        toWrite = rbyte & (0xFF)^(1<<bit)
                    memSegment.write(addr,toWrite,TYPE_MAP[PyTango.DevUChar])
                    reRead = self.read_db.b(self.offset_sp+addr)
                    self.debug_stream("Writing boolean to %6s (%d.%d) byte "\
                                      "was %s; write %s; now %s"
                                      %(value,addr,bit,
                                        bin(rbyte),bin(toWrite),bin(reRead)))
            except Exception,e:
                self.error_stream("Cannot set the bit group: %s"%(e))


        def write_lock(self, value):
            '''
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            rbyte = self.read_db.b(self.locking_raddr)
            wbyte = self.write_db.b(self.locking_waddr)
            if value:
                # sets bit 'bitno' of b
                toWrite = rbyte | (int(value) << self.locking_wbit)
                #a byte of 0s with a unique 1 in the place to set this 1
            else:
                # clears bit 'bitno' of b
                toWrite = rbyte & (0xFF)^(1<<self.locking_wbit)
                #a byte of 1s with a unique 0 in the place to set this 0
            self.write_db.write(self.locking_waddr,toWrite,
                                TYPE_MAP[PyTango.DevUChar])
            reRead = self.read_db.b(self.locking_raddr)
            self.info_stream("Writing Locking boolean to %s (%d.%d) byte "\
                             "was %s; write %s; now %s"
                             %("  lock" if value else "unlock",
                               self.locking_raddr,self.locking_rbit,
                               bin(rbyte),bin(toWrite),bin(reRead)))
            self._plcAttrs['Locking'][WRITEVALUE] = value

        @AttrExc
        def write_Locking(self, attr):
            '''
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            #self.warn_stream('writing locking')
            try:
                self.write_lock(attr.get_write_value())
            except:
                self.error_stream('Trying to write %s/%s and looks to be not '\
                                  'well connected to the plc.'
                                  %(self.get_name(),attr.get_name()))

        def check_lock(self):
            '''Drops lock if write_value is True, but did not receive lock_state
               if re
            '''
            pass

        #----# Ramp area
        @AttrExc
        def write_attr_with_ramp(self, attr):
            '''With this method we specialize the write of an attribute to 
               launch the necessary tools to proceed with the ramping 
               procedure.
            '''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            attrName = attr.get_name()
            data=[]
            attr.get_write_value(data)
            ramp_dest = float(data[0])
            self.info_stream("write_attr_with_ramp(%s: %g)"
                             %(attrName,ramp_dest))
            if self.__isRampingAttr(attrName):
                self._launchRamp(attrName, ramp_dest)

        def _launchRamp(self,attrName,ramp_dest):
            attrStruct = self._getAttrStruct(attrName)
            attrStruct[RAMPDEST] = ramp_dest
            # check if the ramping is active for this attribute before
            # create a thread for it, because if it's inactive this 
            # is like a non-ramping attribute and only requires to 
            # write in WRITEVALUE and send to the plc.
            #  * This is necessary because, in case that thread 
            #  * creation cause problems, this can be disabled and 
            #  * operate normally.
            if self.__isRampEnabled(attrName):
                self.createRampThread(attrName)
            else: 
                self.__moveToValue(attrName,ramp_dest)
            #FIXME: this doesn't support the formula feature for ramping 
            #       attributes.

        def __isRampingAttr(self,attrName):
            attrStruct = self._getAttrStruct(attrName)
            if attrStruct != None and attrStruct.has_key(RAMP) and \
               attrStruct.has_key(RAMPDEST):
                return True
            return False

        def createRampThread(self,attrName):
            '''This creates a thread, if not exist yet, to manage the ramping 
               procedure, returning the asap to the write action.
            '''
            thread = self.__getRampThread(attrName)
            if thread == None:
                if self.__buildRampThread(attrName) == None:
                    reason = "Threading %s not available"%(attrName)
                    description = "We have encountered problems with the "\
                                  "ramp. Please call controls, but you may "\
                                  "work disabling the ramping"
                    PyTango.Except.throw_exception(reason,
                                                   description,
                                                   attrName,
                                                   PyTango.ErrSeverity.ERR)
            else:
                self.info_stream("Already running thread for %s ramp"
                                 %(attrName))

        def __getRampThread(self,attrName):
            '''Know if there is a ramping thread already working for this 
               attribute.
            '''
            try:
                if not hasattr(self,'_rampThreads'):
                    self._rampThreads = {}
                if self._rampThreads.has_key(attrName) and \
                                         self._rampThreads[attrName].isAlive():
                    return self._rampThreads[attrName]
            except Exception,e:
                self.error_stream("Cannot know the ramp threading state for "\
                                  "attribute %s due to: %s"%(attrName,e))
            return None

        def __buildRampThread(self,attrName):
            '''Constructor of the auxiliar thread who will proceed with the 
               ramping, and start it.
            '''
            try:
                if not self._rampThreads.has_key(attrName) or \
                                     not self._rampThreads[attrName].isAlive():
                    self._rampThreads[attrName] = None
                self._rampThreads[attrName] = threading.Thread(
                                       target=self.startRamp,args=([attrName]))
                self.debug_stream("In __buildRampThread(%s): Thread created."
                                 %(attrName))
                self._rampThreads[attrName].start()
                return self._rampThreads[attrName]
            except Exception,e:
                self.error_stream("The ramping thread for attribute %s "\
                                  "cannot be launched due to: %s"%(attrName,e))
            return None

        def startRamp(self,attrName):
            '''This method is a loop to perform a threaded ramp to the given 
               setpoint of an attribute. Being this setpoint modifiable before
               reach it, then evaluating again the behaviour of the ramp.
            '''
            self.info_stream("Thread for attribute %s ramping start."
                             %(attrName))
            while not self.__isRampDone(attrName):
                if threading.current_thread().ident != \
                                             self._rampThreads[attrName].ident:
                    self.warn_stream("I am %s and I'm not responsible for "\
                                     "this ramp! Its %s"
                                     %(threading.current_thread(),
                                       self._rampThreads[attrName].ident))
                    return
                if not self.__isRampEnabled(attrName):
                    #There is a check before create this thread, but it can be
                    #disabled during ramping, and then go directly to the 
                    #destination
                    self.__moveWithoutRamp(attrName)
                rampDirection,rampDetails = self.__getRampStruct(attrName)
                self.debug_stream("Attribute %s ramp direction '%s' "\
                                 "parameters: %s"
                                 %(attrName,rampDirection,rampDetails))
                if rampDirection == None:
                    reason = "Error exception!"
                    description = "Unable to determine the ramp direction!"
                    self.error_stream("%s %s"%(reason,description))
                    PyTango.Except.throw_exception(reason,
                                                   description,
                                                   attrName,
                                                   PyTango.ErrSeverity.ERR)
                    return
                elif rampDetails != None:
                    #TODO: check if the switch has been OFF
                    #      if there is threshold 'go' to it 
                    #      else: 'go' to 0 as it would be the most safe.
                    if not self.__isRampSwitchOk(rampDetails):
                        self.__pauseRamping(attrName,rampDirection,rampDetails)
                    
                    self.__applyAnStep(attrName,rampDirection,rampDetails)
                else:#No details, direct movement
                    self.__moveWithoutRamp(attrName)
            self.info_stream("Ending the ramping thread for attribute %s."
                             %(attrName))
            self._getAttrStruct(attrName)[RAMPDEST] = None
            #self._rampThreads[attrName] = None

        def __isRampDone(self,attrName):
            '''Evaluate if, for a given attribute name, its ramping prodecure
               has been completted. That is to say, the destination of the 
               ramp is already the written value.
            '''
            attrStruct = self._getAttrStruct(attrName)
            if attrStruct[RAMPDEST] == None:
                #Never have run a ramp
                return True
            if attrStruct != None:
                return attrStruct[RAMPDEST] == attrStruct[WRITEVALUE]
                #FIXME: perhaps could be more interesting to compare with 
                #       the read_value and if they are 'close' each other.
                #abs(attrStruct[RAMPDEST] - attrStruct[READVALUE]) < epsilon
            return False

        def __isRampEnabled(self,attrName):
            '''Give any of the attributes, return a boolean responding the 
               question of if it's the ramp enabled in this particular 
               attribute.
            '''
            rampEnabledAttr = attrName+'_'+RAMPENABLE
            rampEnabledStruct = self._getAttrStruct(rampEnabledAttr)
            if rampEnabledStruct != None:
                isEnable = rampEnabledStruct[READVALUE]
                self.debug_stream("Ramp for attr %s %s"
                             %(attrName,"enabled" if isEnable else "disabled"))
                return isEnable
            return False

        def __getRampStruct(self,attrName):
            '''Base on the RAMPDEST and the WRITEVALUE, determine if the
               ramp to do is ASCENDING or DESCENDING. Then return the 
               direction tag together with the underlying structure to proceed
               with the ramp, in case there exist.
            '''
            if self.__isRampingAttr(attrName):
                attrStruct = self._getAttrStruct(attrName)
                if attrStruct[RAMPDEST] > attrStruct[WRITEVALUE]:
                    if attrStruct[RAMP].has_key(ASCENDING):
                        return (ASCENDING,attrStruct[RAMP][ASCENDING])
                    else:
                        return (ASCENDING,None)
                elif attrStruct[RAMPDEST] < attrStruct[WRITEVALUE]:
                    if attrStruct[RAMP].has_key(DESCENDING):
                        return (DESCENDING,attrStruct[RAMP][DESCENDING])
                    else:
                        return (DESCENDING,None)
            return (None,None)

        def __moveWithoutRamp(self,attrName):
            '''Apply a direct setpoint to where the ramp has the destination.
            '''
            if self.__isRampingAttr(attrName):
                attrStruct = self._getAttrStruct(attrName)
                self.__moveToValue(attrName, attrStruct[RAMPDEST])

        def __moveToValue(self,attrName,value):
            '''Used to provide a common method to all the ramp movement types.
            '''
            if self.__isRampingAttr(attrName):
                self.debug_stream("Apply to %s an %s"%(attrName,value))
                attrStruct = self._getAttrStruct(attrName)
                attrStruct[WRITEVALUE] = value
                self.write_db.write(attrStruct[WRITEADDR],
                                    value,
                                    attrStruct[TYPE])

        def __applyAnStep(self,attrName,direction,details):
            '''Based on the ramp definition, decide if next step is to:
               - go to the threshold
               - increase/decrease the step
               - finish the ramp when too close
            '''
            attrStruct = self._getAttrStruct(attrName)
            #TODO: threshold
            if attrStruct != None and \
               direction in [ASCENDING,DESCENDING] and \
               details.has_key(STEP) and \
               details.has_key(STEPTIME):
                #prepare
                currentValue = attrStruct[WRITEVALUE]
                destinationValue = attrStruct[RAMPDEST]
                step = details[STEP]
                steptime = details[STEPTIME]
                if details.has_key(THRESHOLD):
                    threshold = details[THRESHOLD]
                else:
                    threshold = None
                if currentValue == None:
                    self.error_stream("Cannot determine where %s is with "\
                                      "a %s = %s"
                                      %(attrName,WRITEVALUE,currentValue))
                    time.sleep(EVENT_THREAD_PERIOD)
                    return
                self.debug_stream("Moving %s in '%s' direction from %s to %s "\
                                 "(step %s,threshold = %s)"
                                 %(attrName,direction,
                                   currentValue,destinationValue,
                                   step,threshold))
                if direction == ASCENDING:
                    if currentValue < threshold:
                        self.debug_stream("Moving %s to the threshold %s"
                                         %(attrName,threshold))
                        value = min(threshold,destinationValue)
                    elif destinationValue-currentValue < step:
                        value = destinationValue
                    else:
                        value = currentValue+step
                elif direction == DESCENDING:
                    if currentValue > threshold:
                        self.debug_stream("Moving %s to the threshold %s"
                                         %(attrName,threshold))
                        value = max(threshold,destinationValue)
                    elif currentValue-destinationValue < step:
                        value = destinationValue
                    else:
                        value = currentValue-step
                self.__moveToValue(attrName,value)
                time.sleep(details[STEPTIME])

        def __isRampSwitchOk(self,details):
            '''Given the details of a ramp in a particular direction, check if
               there has been configured an switch attribute decide if the ramp
               is ok, but if there isn't an attribute it's assumed and ok.
            '''
            if details.has_key(SWITCH):
                switchName = details[SWITCH]
                return bool(self.__getAttrReadValue(switchName))
            else:
                return True

        def __pauseRamping(self,attrName,direction,details):
            '''Active waiting for the ramping resume. If the current value is
               in the ramping region, pause it in the threshold (it it exists,
               or at 0 as the most safe value).
            '''
            attrStruct = self._getAttrStruct(attrName)
            currentValue = attrStruct[WRITEVALUE]
            destinationValue = attrStruct[RAMPDEST]
            if details.has_key(THRESHOLD):
                threshold = details[THRESHOLD]
            else:
                threshold = 0
            if self.__isInRampingArea(direction,currentValue,threshold):
                self.info_stream("Pausing %s to the threshold"%(attrName))
                self.__moveToValue(attrName,threshold)
            while not self.__isRampSwitchOk(details):
                self.debug_stream("Waiting to resume %s ramp"%(attrName))
                time.sleep(details[STEPTIME])
            self.info_stream("Resuming %s ramp from the threshold"%(attrName))

        def __isInRampingArea(self,direction,currentValue,threshold):
            '''Given a direction check if the current value is in the region
               where it must be ramped.
            '''
            if direction == ASCENDING and currentValue > threshold:
                return True
            elif direction == DESCENDING and currentValue < threshold:
                return True
            return False

        def createSwitchStateThread(self,attrName):
            '''This creates a thread, if not exist yet, to manage the switch
               state change procedure.
            '''
            thread = self.__getSwitchThread(attrName)
            if thread == None:
                if self.__buildSwitchThread(attrName) == None:
                    reason = "Threading %s not available"%write_value
                    description = "We have encountered problems with the "\
                                  "switch procedure. Please call controls, "\
                                  "but you may work disabling this feature."
                    PyTango.Except.throw_exception(reason,
                                                   description,
                                                   attrName,
                                                   PyTango.ErrSeverity.ERR)

        def __getSwitchThread(self,attrName):
            '''If there is already a thread doing the switch procedure return
               it, or create it to do it.
            '''
            try:
                if not hasattr(self,'_switchThreads'):
                    self._switchThreads = {}
                if self._switchThreads.has_key(attrName) and \
                                      self._switchThreads[attrName].isAlive():
                    return self._switchThreads[attrName]
            except Exception,e:
                self.error_stream("Cannot know the switch threading state for"\
                                  " attribute %s due to: %s"%(attrName,e))
            return None

        def __buildSwitchThread(self,attrName):
            '''Build the auxiliar thread who will take care of the procedure
               to do the switch state in the boolean.
            '''
            try:
                if not self._switchThreads.has_key(attrName) or \
                                   not self._switchThreads[attrName].isAlive():
                    self._switchThreads[attrName] = None
                self._switchThreads[attrName] = threading.Thread(
                                     target=self.startSwitch,args=([attrName]))
                self.info_stream("In createSwitchStateThread(%s): Thread "\
                                 "created."%(attrName))
                self._switchThreads[attrName].start()
                return self._switchThreads[attrName]
            except Exception,e:
                self.error_stream("The switch thread for attribute %s "\
                                  "cannot be launched due to: %s"%(attrname,e))
            return None

        def startSwitch(self,attrName):
            '''This method starts a ramping procedure in order to safely do
               a state transition before apply the modification.
               attrName corresponds to the boolean attribute.
            '''
            self.info_stream("Thread for attribute %s switch start."
                             %(attrName))
            attrStruct = self._getAttrStruct(attrName)
            currentState = attrStruct[READVALUE]
            destinationState = attrStruct[SWITCHDEST]
            transition,switchStruct = self.__getSwitchStruct(attrName)
            if transition == None or switchStruct == None:
                self.warn_stream("No transition expected for %s from %s to %s"
                                 %(attrName,currentState,destinationState))
                self._applyWriteBit(attrName,destinationState)
                return
            #once know there shall be transition, get information about the 
            #attribute that has to do this transition.
            rampAttr = switchStruct[ATTR2RAMP]
            rampStruct = self._getAttrStruct(rampAttr)
            rampBackup = rampStruct[WRITEVALUE]#back up the current write value
            rampFrom,rampTo = self.__getSwitchInteval(attrName)
            if rampFrom != None and rampTo == None:
                #start from where it say with end where it is
                rampTo = rampBackup
            elif rampFrom == None and rampTo != None:
                #start from where it is and end where it say
                rampFrom = rampBackup
            elif rampFrom == None and rampTo == None:
                #nothing defined, then by default act depending on the 
                #transition.
                if transition == WHENON:
                    rampFrom = 0
                    rampTo = rampBackup
                elif transition == WHENOFF:
                    rampFrom = rampBackup
                    rampTo = 0
            self.info_stream("Start a '%s' transition for %s with a ramp of "\
                             "%s from %s to %s"
                             %(transition,attrName,rampAttr,rampFrom,rampTo))
            #prepare first by placing the origin in the 'from'
            rampStruct[RAMPDEST] = rampFrom
            self.__moveWithoutRamp(rampAttr)
            time.sleep(EVENT_THREAD_PERIOD)
            #when switch on, it's necessary to power up before start
            if transition == WHENON:
                while not attrStruct[READVALUE] == destinationState:
                    self._applyWriteBit(attrName,destinationState)
                    self.info_stream("waiting to switch ON (%s)"
                                     %(destinationState))
                    time.sleep(EVENT_THREAD_PERIOD)
                    currentState = attrStruct[READVALUE]
            #Now the value can be applyed (and ramp if it has it)
            self._launchRamp(rampAttr,rampTo)
            while self.__wait4ramp(rampAttr) == True:
                pass
            #when switch off, it's necessary to power down after
            if transition == WHENOFF:
                while not attrStruct[READVALUE] == destinationState:
                    self._applyWriteBit(attrName,destinationState)
                    self.info_stream("waiting to switch OFF (%s)"
                                     %(destinationState))
                    time.sleep(EVENT_THREAD_PERIOD)
                    currentState = attrStruct[READVALUE]
            self.info_stream("Ending the switch thread for attribute %s."
                             %(attrName))
            self._getAttrStruct(attrName)[SWITCHDEST] = None
            self.info_stream("Setting back the previous sepoint to %s (%g)"
                             %(rampAttr,rampBackup))
            time.sleep(EVENT_THREAD_PERIOD)
            rampStruct[RAMPDEST] = rampBackup
            self.__moveWithoutRamp(rampAttr)
            

        def __getSwitchStruct(self,attrName):
            attrStruct = self._getAttrStruct(attrName)
            if self.__stateTransitionToOn(attrStruct[SWITCHDEST],
                                          attrStruct[SWITCHDESCRIPTOR]):
                return (WHENON,attrStruct[SWITCHDESCRIPTOR])
            elif self.__stateTransitionToOff(attrStruct[SWITCHDEST],
                                             attrStruct[SWITCHDESCRIPTOR]):
                return (WHENOFF,attrStruct[SWITCHDESCRIPTOR])
            return (None,None)
        
        def __getSwitchInteval(self,attrName):
            transition,switchStruct = self.__getSwitchStruct(attrName)
            switchStruct[transition]
            if switchStruct[transition].has_key(TO):
                to_ = switchStruct[transition][TO]
            else:
                to_ = None
            if switchStruct[transition].has_key(FROM):
                from_ = switchStruct[transition][FROM]
            else:
                from_ = None
            return (from_,to_)

        def __wait4ramp(self,attrName):
            attrStruct = self._getAttrStruct(attrName)
            direction,rampStruct = self.__getRampStruct(attrName)
            if rampStruct == None:
                self.info_stream("No ramp to wait for %s"%(attrName))
                return False#ramp done
            currentValue = attrStruct[WRITEVALUE]
            destinationValue = attrStruct[RAMPDEST]
            if destinationValue == None:
                self.info_stream("No ramp to wait for %s"%(attrName))
                return False#ramp done
            stepsDelta = rampStruct[STEP]
            guestSteps = (abs(currentValue-destinationValue)/stepsDelta)+1
            waitTime = rampStruct[STEPTIME]*guestSteps
            self.info_stream("Launched the ramp for %s, waiting %d steps "\
                             "(that would be about %g seconds until it should"\
                             " have ended..."%(attrName,guestSteps,waitTime))
            time.sleep(waitTime)
            #check where it's after the wait to know if there is need more time
            if attrStruct[WRITEVALUE] != attrStruct[RAMPDEST]:
                return True
            return False
            

        def _applyWriteBit(self,attrName,value):
            attrStruct = self._getAttrStruct(attrName)
            read_addr = attrStruct[READADDR]
            write_addr = attrStruct[WRITEADDR]
            write_bit = attrStruct[WRITEBIT]
            self.__writeBit(attrName,read_addr,write_addr,write_bit,value)
            attrStruct[WRITEVALUE] = value

        #---- done Ramp area

        @AttrExc
        def write_internal_attr(self,attr):
            '''
            '''
            '''this is referencing to a device attribute that doesn't
               have plc representation'''
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            attrName = attr.get_name()
            self.debug_stream('write_internal_attr(%s)'%(attrName))
            
            data=[]
            attr.get_write_value(data)
            #----FIXME: some cases must not allow values <= 0
            if self._internalAttrs.has_key(attrName):
                attrDescr = self._internalAttrs[attrName]
                if attrDescr.has_key(WRITEVALUE):
                    attrDescr[WRITEVALUE] = data[0]
                    if attrDescr[TYPE] in [PyTango.DevDouble,
                                             PyTango.DevFloat]:
                        attrValue = float(data[0])
                    elif attrDescr[TYPE] in [PyTango.DevBoolean]:
                        attrValue = bool(data[0])
                    attrDescr[READVALUE] = attrValue
                    attrQuality = self.__buildAttrQuality(attrName,
                                                       attrDescr[READVALUE])
                    self.storeDynMemozized(attr)
                    if attrDescr.has_key(EVENTS):
                        self.fireEventsList([attrName,attrValue,
                                             attrQuality],log=True)

        @AttrExc
        def read_lastUpdateStatus(self,attr):
            '''
            '''
#            self.debug_stream('read_lastUpdateStatus(%s)'%(attr.get_name()))
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            attr.set_value(self.read_lastUpdateStatus_attr)

        @AttrExc
        def read_lastUpdate(self,attr):
            '''
            '''
#            self.debug_stream('read_lastUpdate(%s)'%(attr.get_name()))
            if self.get_state()==PyTango.DevState.FAULT or \
                                               (not self.has_data_available()):
                return #raise AttributeError("Not available in fault state!")
            attr.set_value(self.read_lastUpdate_attr)
            
        def storeDynMemozized(self,attr):
            '''When a write attr operation, does a change on what was stored'''
            attrName = attr.get_name()
            if self._internalAttrs.has_key(attrName):
                attrDescr = self._internalAttrs[attrName]
                if attrDescr.has_key(WRITEVALUE):
                    value = attrDescr[WRITEVALUE]
                    self.debug_stream("memorising attr %s with value %s"
                                      %(attrName,value))
                    #extract and push the value to the properties
                    db = PyTango.Database()
                    prop_names = db.get_device_property_list(self.get_name(),
                                                             "*")
                    prop_values = db.get_device_property(self.get_name(),
                                                       prop_names.value_string)
                    prop_values[attr.get_name()] = value
                    db.put_device_property(self.get_name(), prop_values)
            
        def recoverDynMemorized(self,attrName):
            '''When, from what was stored, is wanted to be set'''
            if self._internalAttrs.has_key(attrName):
                attrDescr = self._internalAttrs[attrName]
                if self._internalAttrs[attrName].has_key(TYPE):
                    attrType = self._internalAttrs[attrName][TYPE]
                    #once this is clear, data can be recovered from the
                    #database and casted properly
                    db = PyTango.Database()
                    prop_names = db.get_device_property_list(self.get_name(),
                                                             "*")
                    prop_values = db.get_device_property(self.get_name(),
                                                       prop_names.value_string)
                    if attrType in [PyTango.DevDouble,PyTango.DevFloat]:
                        return float(prop_values[attrName][0])
                    elif attrType == PyTango.DevBoolean:
                        return bool(prop_values[attrName][0])

        #---- Done Write Attr method for dynattrs

        #----- PROTECTED REGION END -----#    //    LinacData.global_variables

        def __init__(self,cl, name):
                PyTango.Device_4Impl.__init__(self,cl,name)
                self.log = self.get_logger()
                LinacData.init_device(self)

        def delete_device(self):
                self.info_stream('deleting device '+self.get_name())
                self._plcUpdateJoiner.set()
                self._tangoEventsJoiner.set()
                self.attr_list.remove_all()

        def init_device(self):
            try:
                self.debug_stream("In "+self.get_name()+"::init_device()")
                self.set_change_event('State', True, False)
                self.set_change_event('Status', True, False)
                #The attributes Locking, Lock_ST, and HeartBeat have also 
                #events but this call is made in each of the AttrList method
                #who dynamically build them.
                self.set_state(PyTango.DevState.INIT)
                self.set_status('inititalizing...')
                self.get_device_properties(self.get_device_class())
                self.debug_stream('AttrFile='+str(self.AttrFile))
                self._locals = { 'self' : self }
                self._globals = globals()
                #String with human infomation about the last update
                self.read_lastUpdateStatus_attr = ""
                attr = PyTango.Attr('lastUpdateStatus',
                                    PyTango.DevString,PyTango.READ)
                attrProp = PyTango.UserDefaultAttrProp()
                attrProp.set_label('Last Update Status')
                attr.set_default_properties(attrProp)
                self.add_attribute(attr, r_meth=self.read_lastUpdateStatus)
                self.set_change_event('lastUpdateStatus', True, False)
                #numeric attr about the lapsed time of the last update
                self.read_lastUpdate_attr = None
                attr = PyTango.Attr('lastUpdate',
                                    PyTango.DevDouble,PyTango.READ)
                attrProp = PyTango.UserDefaultAttrProp()
                attrProp.set_format(latin1('%f'))
                attrProp.set_label('Last Update')
                attrProp.set_unit('s')
                attr.set_default_properties(attrProp)
                self.add_attribute(attr, r_meth=self.read_lastUpdate)
                self.set_change_event('lastUpdate', True, False)

                self.attr_list = AttrList(self)
                
                ########
                # region to setup the network communication parameters

                # restrictions and rename of PLC's ip address
                if self.IpAddress == '' and self.PlcAddress == '':
                    self.error_stream("The PLC ip address must be set")
                    self.set_state(PyTango.DevState.FAULT)
                    self.set_status("Please set the PlcAddress property",
                                    important=True)
                    return
                elif not self.IpAddress == '' and self.PlcAddress == '':
                    self.warn_stream("Deprecated property IpAddress, "\
                                     "please use PlcAddress")
                    self.PlcAddress = self.IpAddress
                elif not self.IpAddress == '' and not self.PlcAddress == '' \
                     and not self.IpAddress == self.PlcAddress:
                    self.warn_stream("Both PlcAddress and IpAddress "\
                                     "properties are defined and with "\
                                     "different values, prevail PlcAddress")

                # get the ip address of the host where the device is running
                # this to know if the device is running in local or remote
                thisHostIp = get_ip()
                if not thisHostIp == self.BindAddress:
                    if not self.BindAddress == '':
                        self.warn_stream("BindAddress property defined but "\
                                         "deprecated and it doesn't match "\
                                         "with the host where device runs. "\
                                         "Overwrite BindAddress with '%s'"
                                         %thisHostIp)
                    else:
                        self.debug_stream("BindAddress of this host '%s'"
                                         %(thisHostIp))
                    self.BindAddress = thisHostIp

                # check if the port corresponds to local and remote modes
                if thisHostIp == self.LocalAddress:
                    self.info_stream('Connection to the PLC will be '\
                                     'local mode')
                    self.set_status('Connection in local mode',important=True)
                    self._deviceIsInLocal = True
                    self._deviceIsInRemote = False
                    try:
                        if not self.LocalPort == None:
                            self.info_stream('Using specified local port %s'
                                             %(self.LocalPort))
                            self.Port = self.LocalPort
                        else:
                            self.warn_stream('Local port not specified, '\
                                             'trying to use deprecated '\
                                             'definition')
                            if self.Port > 2010:
                                self.Port -= 10
                                self.warn_stream('converted the port to local'\
                                                 ' %s'%self.Port)
                    except:
                        self.error_stream('Error in the port setting')
                elif thisHostIp == self.RemoteAddress:
                    self.info_stream('Connection to the PLC with be '\
                                     'remote mode')
                    self.set_status('Connection in remote mode',important=True)
                    self._deviceIsInLocal = False
                    self._deviceIsInRemote = True
                    try:
                        if not self.RemotePort == None:
                            self.info_stream('Using specified remote port %s'
                                             %(self.RemotePort))
                            self.Port = self.RemotePort
                        else:
                            self.warn_stream('Remote port not specified, '\
                                             'trying to use deprecated '\
                                             'definition')
                            if self.Port < 2010:
                                self.Port += 10
                                self.warn_stream('converted the port to '\
                                                 'remote %s'%(self.RemotePort))
                    except:
                        self.error_stream('Error in the port setting')
                else:
                    self.warn_stream('Unrecognized IP for local/remote '\
                                     'modes (%s)'%thisHostIp)
                    self.set_status('Unrecognized connection for local/remote'\
                                    ' mode',important=True)
                    self._deviceIsInLocal = False
                    self._deviceIsInRemote = False

                # restrictions and renames of the Port's properties
                if self.Port == None:
                    self.debug_stream("The PLC ip port must be set")
                    self.set_state(PyTango.DevState.FAULT)
                    self.set_status("Please set the plc ip port",
                                    important=True)
                    return

                # end the region to setup the network communication parameters
                ########

                if self.ReadSize <= 0 or self.WriteSize <= 0:
                    self.set_state(PyTango.DevState.FAULT)
                    self.set_status("Block Read/Write sizes not well "\
                                    "set (r=%d,w=%d)"
                                    %(self.ReadSize,self.WriteSize),
                                    important=True)
                    return
#                if not self.ReadSize % 2 == 0:
#                    self.set_state(PyTango.DevState.FAULT)
#                    self.set_status("Block Read size must be multiple "\
#                                    "of 2 (r=%d)"
#                                    %(self.ReadSize),important=True)
#                    return

                # true when reading some attribute failed....
                self.tainted = ''
                # where the readback of the set points begins
                self.offset_sp = self.ReadSize-self.WriteSize

                self.attr_loaded = False
                self.last_update_time = time.time()

                try:
                     self.connect()
                except Exception:
                     traceback.print_exc()
                     self.disconnect()
                     self.set_state(PyTango.DevState.UNKNOWN)
                self.set_status('initialized')
                self.info_stream('initialized')
                self.set_state(PyTango.DevState.UNKNOWN)

                #---- Threading joiners
                self._plcUpdateJoiner = threading.Event()
                self._plcUpdateJoiner.clear()
                self._tangoEventsJoiner = threading.Event()
                self._tangoEventsJoiner.clear()
                #---- Threads declaration
                self._tangoEventsThread = threading.Thread(
                                             target=self.eventGeneratorThread)
                self._tangoEventsTime = CircularBuffer([],maxlen=250)
                self._tangoEventsNumber = CircularBuffer([],maxlen=250)
                self._plcUpdateThread = threading.Thread(
                                                 target=self.plcUpdaterThread)
                #---- Threads configuration
                self._tangoEventsThread.setDaemon(True)
                self._plcUpdateThread.setDaemon(True)
                self._plcUpdatePeriod = PLC_MAX_UPDATE_PERIOD
                #---- Launch those threads
                self._plcUpdateThread.start()
                self._tangoEventsThread.start()
                self.info_stream("All threads launched")
                #---- When the device starts from scratch in local mode, 
                #     try to lock the PLC control
                #if _deviceIsInLocal:
                #    self.write_lock(True)
            except Exception:
                self.error_stream('initialization failed')
                self.debug_stream(traceback.format_exc())
                self.set_state(PyTango.DevState.FAULT)
                self.set_status(traceback.format_exc())
                #raise

         #-----------------------------------------------------------------------------
         #    LinacData read/write attribute methods
         #-----------------------------------------------------------------------------
    
        #----- PROTECTED REGION ID(LinacData.initialize_dynamic_attributes) ENABLED START -----#
        def initialize_dynamic_attributes(self):
            self.ReloadAttrFile()
        #Read to the hardware is made periodically by Update() Cmd.
#        def read_attr_hardware(self, data):
#            self.debug_stream("In read_attr_hardware()")
#            #----- PROTECTED REGION ID(LinacData.read_attr_hardware) ENABLED START -----#
#            pass
#            #----- PROTECTED REGION END -----#    //    LinacData.read_attr_hardware
        #----- PROTECTED REGION END -----#    //    LinacData.initialize_dynamic_attributes

        #------------------------------------------------------------------
        #    Read EventsTime attribute
        #------------------------------------------------------------------
        def read_EventsTime(self, attr):
            self.debug_stream("In " + self.get_name() + ".read_EventsTime()")
            #----- PROTECTED REGION ID(LinacData.EventsTime_read) ENABLED START -----#
            self.attr_EventsTime_read = self._tangoEventsTime.array
            #----- PROTECTED REGION END -----#    //    LinacData.EventsTime_read
            attr.set_value(self.attr_EventsTime_read)

        #------------------------------------------------------------------
        #    Read EventsNumber attribute
        #------------------------------------------------------------------
        def read_EventsNumber(self, attr):
            self.debug_stream("In " + self.get_name() + ".read_EventsNumber()")
            #----- PROTECTED REGION ID(LinacData.EventsNumber_read) ENABLED START -----#
            self.attr_EventsNumber_read = self._tangoEventsNumber.array
            #----- PROTECTED REGION END -----#    //    LinacData.EventsNumber_read
            attr.set_value(self.attr_EventsNumber_read)
            

        #-----------------------------------------------------------------------------
        #    LinacData command methods
        #-----------------------------------------------------------------------------
        @CommandExc
        def ReloadAttrFile(self):
            """ Reload the file containing the attr description for a particular plc
            
            :param argin: 
            :type: PyTango.DevVoid
            :return: 
            :rtype: PyTango.DevVoid """
            self.debug_stream('In ReloadAttrFile()')
            #----- PROTECTED REGION ID(LinacData.ReloadAttrFile) ENABLED START -----#
            self.attr_loaded = True
            if self.AttrFile:
                attr_fname = self.AttrFile
            else:
                attr_fname = self.get_name().split('/')[-1]+'.py'
            try:
                self.attr_list.parse_file(attr_fname.lower())
            except Exception,e:
                if self.get_state() != PyTango.DevState.FAULT:
                    self.set_state(PyTango.DevState.FAULT)
                    self.set_status("ReloadAttrFile() failed (%s)"%(e),
                                    important=True)
            #----- PROTECTED REGION END -----#    //    LinacData.ReloadAttrFile

        @CommandExc
        def Exec(self, cmd):
            """ Direct command to execute python with in the device, use it 
                very carefully it's good for debuging but it's a security thread
            
            :param argin: 
            :type: PyTango.DevString
            :return: 
            :rtype: PyTango.DevString """
            self.debug_stream('In Exec()')
            #----- PROTECTED REGION ID(LinacData.Exec) ENABLED START -----#
            L = self._locals
            G = self._globals
            try:
                try:
                    # interpretation as expression
                    result = eval(cmd, G, L)
                except SyntaxError:
                    # interpretation as statement
                    exec cmd in G, L
                    result = L.get("y")

            except Exception, exc:
                # handles errors on both eval and exec level
                result = exc

            if type(result)==StringType:
                return result
            elif isinstance(result, BaseException):
                return "%s!\n%s" % (result.__class__.__name__, str(result))
            else:
                return pprint.pformat(result)
            #----- PROTECTED REGION END -----#    //    LinacData.Exec

        @CommandExc
        def GetBit(self, args):
            """ Command to direct Read a bit position from the PLC memory
            
            :param argin: 
            :type: PyTango.DevVarShortArray
            :return: 
            :rtype: PyTango.DevBoolean """
            self.debug_stream('In GetBit()')
            #----- PROTECTED REGION ID(LinacData.GetBit) ENABLED START -----#
            idx,bitno = args
            return self.read_db.bit(idx, bitno)
            #----- PROTECTED REGION END -----#    //    LinacData.GetBit

        @CommandExc
        def GetByte(self, idx):
            """ Command to direct Read a byte position from the PLC memory
            
            :param argin: 
            :type: PyTango.DevShort
            :return: 
            :rtype: PyTango.DevShort """
            self.debug_stream('In GetByte()')
            #----- PROTECTED REGION ID(LinacData.GetByte) ENABLED START -----#
            return self.read_db.b(idx)
            #----- PROTECTED REGION END -----#    //    LinacData.GetByte

        @CommandExc
        def GetShort(self, idx):
            """ Command to direct Read two consecutive byte positions from the 
                PLC memory and understand it as an integer
            
            :param argin: 
            :type: PyTango.DevShort
            :return: 
            :rtype: PyTango.DevShort """
            self.debug_stream('In GetShort()')
            #----- PROTECTED REGION ID(LinacData.GetShort) ENABLED START -----#
            return self.read_db.i16(idx)
            #----- PROTECTED REGION END -----#    //    LinacData.GetShort

        @CommandExc
        def GetFloat(self, idx):
            """ Command to direct Read four consecutive byte positions from the 
                PLC memory and understand it as an float
            
            :param argin: 
            :type: PyTango.DevShort
            :return: 
            :rtype: PyTango.DevFloat """
            self.debug_stream('In GetFloat()')
            #----- PROTECTED REGION ID(LinacData.GetFloat) ENABLED START -----#
            return self.read_db.f(idx)
            #----- PROTECTED REGION END -----#    //    LinacData.GetFloat

        @CommandExc
        def HexDump(self):
            """ Hexadecimal dump of all the registers in the plc
            
            :param argin: 
            :type: PyTango.DevVoid
            :return: 
            :rtype: PyTango.DevString """
            self.debug_stream('In HexDump()')
            #----- PROTECTED REGION ID(LinacData.HexDump) ENABLED START -----#
            read_txt = ' '.join("%02x" % x for x in self.read_db.buf)
            write_txt = ' '.join("%02x" % x for x in self.write_db.buf)
            return read_txt+'\n'+write_txt
            #----- PROTECTED REGION END -----#    //    LinacData.HexDump

        @CommandExc
        def Hex(self, idx):
            """ Hexadecimal dump the given register of the plc
            
            :param argin: 
            :type: PyTango.DevShort
            :return: 
            :rtype: PyTango.DevString """
            self.debug_stream('In Hex()')
            #----- PROTECTED REGION ID(LinacData.Hex) ENABLED START -----#
            return hex(self.read_db.b(idx))
            #----- PROTECTED REGION END -----#    //    LinacData.Hex

        @CommandExc
        def DumpTo(self, arg):
            """ Hexadecimal dump of all the registers in the plc to a file
            
            :param argin: 
            :type: PyTango.DevString
            :return: 
            :rtype: PyTango.DevVoid """
            self.debug_stream('In DumpTo()')
            #----- PROTECTED REGION ID(LinacData.DumpTo) ENABLED START -----#
            fout = open(arg, 'w')
            fout.write(self.read_db.buf.tostring())
            #----- PROTECTED REGION END -----#    //    LinacData.DumpTo

        @CommandExc
        def WriteBit(self, args):
            """ Write a single bit in the memory of the plc [reg,bit,value]
            
            :param argin: 
            :type: PyTango.DevVarShortArray
            :return: 
            :rtype: PyTango.DevVoid """
            self.debug_stream('In WriteBit()')
            #----- PROTECTED REGION ID(LinacData.WriteBit) ENABLED START -----#
            idx, bitno, v = args
            idx += bitno / 8
            bitno %= 8
            v = bool(v)
            b = self.write_db.b(idx)#Get the byte where the bit is
            b = b & ~(1<<bitno) | (v<<bitno)#change only the expected bit
            #The write operation of a bit, writes the Byte where it is
            self.write_db.write(idx,b,TYPE_MAP[PyTango.DevUChar])
            #----- PROTECTED REGION END -----#    //    LinacData.WriteBit

        @CommandExc
        def WriteByte(self, args):
            """ Write a byte in the memory of the plc [reg,value]
            
            :param argin: 
            :type: PyTango.DevVarShortArray
            :return: 
            :rtype: PyTango.DevVoid """
            self.debug_stream('In WriteByte()')
            #----- PROTECTED REGION ID(LinacData.WriteByte) ENABLED START -----#
            print(args)
            #args[1] = c_uint8(args[1])
            register = args[0]
            value = uint8(args[1])
            #self.write_db.write( *args )
            self.write_db.write(register,value,TYPE_MAP[PyTango.DevUChar])
            #----- PROTECTED REGION END -----#    //    LinacData.WriteByte

        @CommandExc
        def WriteShort(self, args):
            """ Write two consecutive bytes in the memory of the plc [reg,value]
            
            :param argin: 
            :type: PyTango.DevVarShortArray
            :return: 
            :rtype: PyTango.DevVoid """
            self.debug_stream('In WriteShort()')
            #----- PROTECTED REGION ID(LinacData.WriteShort) ENABLED START -----#
            #args[1] = c_int16(args[1])
            register = args[0]
            value = int16(args[1])
            #self.write_db.write( *args )
            self.write_db.write(register,value,TYPE_MAP[PyTango.DevShort])
            #----- PROTECTED REGION END -----#    //    LinacData.WriteShort

        @CommandExc
        def WriteFloat(self, args):
            """ Write the representation of a float in four consecutive bytes 
                in the memory of the plc [reg,value]
            
            :param argin: 
            :type: PyTango.DevVarShortArray
            :return: 
            :rtype: PyTango.DevVoid """
            self.debug_stream('In WriteFloat()')
            #----- PROTECTED REGION ID(LinacData.WriteFloat) ENABLED START -----#
            idx = int(args[0])
            f = float32(args[1])
            self.write_db.write(idx,f,TYPE_MAP[PyTango.DevFloat])
            #----- PROTECTED REGION END -----#    //    LinacData.WriteFloat

        @CommandExc
        def ResetState(self):
            """ Clean the information set in the Status message and restore 
                the state
            
            :param argin: 
            :type: PyTango.DevVoid
            :return: 
            :rtype: PyTango.DevVoid """
            self.debug_stream('In ResetState()')
            #----- PROTECTED REGION ID(LinacData.ResetState) ENABLED START -----#
            self.info_stream('resetting state %s...' % str(self.get_state()))
            if self.get_state() == PyTango.DevState.FAULT:
                if self.disconnect():
                    self.set_state(PyTango.DevState.OFF)#self.connect()
            elif self.is_connected():
                self.set_state(PyTango.DevState.ON)
                self.clean_status()
            else:
                self.set_state(PyTango.DevState.UNKNOWN)
                self.set_status("")
            #----- PROTECTED REGION END -----#    //    LinacData.ResetState


        #---- To be moved
        def plcBasicAttrEvents(self):
            '''This method is used, after all reading from the PLC to update
               the most basic attributes to indicate everything is fine.
               Those attributes are:
               - lastUpdate{,Status}
               - HeartBeat
               - Lock_{ST,Status}
               - Locking
            '''
            now = self.last_update_time#time.time()
            attr2Event = []
            #Heartbit
            self.read_heartbeat_attr = self.read_db.bit(self.heartbeat_addr,0)
            HeartBeatStruct = self._getAttrStruct('HeartBeat')
            if not self.read_heartbeat_attr == HeartBeatStruct[READVALUE]:
                HeartBeatStruct[READVALUE] = self.read_heartbeat_attr
                HeartBeatStruct[READTIME] = time.time()
                attr2Event.append(['HeartBeat',self.read_heartbeat_attr])
            #Locks
            self.read_lock_ST_attr = self.read_db.get(self.lock_ST,'B',1)
            lock_str,lock_quality = self.convert_Lock_ST()
            if not self.read_lock_ST_attr in [0,1,2]:
                self.warn_stream("<<<Invalid locker code %d>>>"
                                 %(self.read_lock_ST_attr))
            Lock_STStruct = self._getAttrStruct('Lock_ST')
            if not self.read_lock_ST_attr == Lock_STStruct[READVALUE]:# or\
               #(now - Lock_STStruct[READTIME]) > PERIODIC_EVENT:
                Lock_STStruct[READVALUE] = self.read_lock_ST_attr
                Lock_STStruct[READTIME] = time.time()
                attr2Event.append(['Lock_ST',self.read_lock_ST_attr,
                                   lock_quality])
            Lock_StatusStruct = self._getAttrStruct('Lock_Status')
            if not lock_str == Lock_StatusStruct[READVALUE]:# or\
               #(now - Lock_StatusStruct[READTIME]) > PERIODIC_EVENT:
                Lock_StatusStruct[READVALUE] = lock_str
                Lock_StatusStruct[READTIME] = time.time()
                attr2Event.append(['Lock_Status',lock_str,lock_quality])
            #locking = self.read_lock()
            LockingStruct = self._getAttrStruct('Locking')
            if not self.is_lockedByTango == LockingStruct[READVALUE]:# or\
               #(now - LockingStruct[READTIME]) > PERIODIC_EVENT:
                LockingStruct[READVALUE] = self.is_lockedByTango
                LockingStruct[READTIME] = time.time()
                attr2Event.append(['Locking',self.is_lockedByTango])
            if len(attr2Event) > 0:
                self.fireEventsList(attr2Event)

        def __attrHasEvents(self,attrName):
            '''
            '''
            if self._plcAttrs.has_key(attrName) and \
               self._plcAttrs[attrName].has_key(EVENTS):
                return True
            elif self._internalAttrs.has_key(attrName) and \
                 self._internalAttrs[attrName].has_key(EVENTS):
                return True
            return False

        def __getAttrReadValue(self,attrName):
            '''
            '''
            attrStruct = self._getAttrStruct(attrName)
            if attrStruct.has_key(READVALUE):
                if type(attrStruct[READVALUE]) == CircularBuffer:
                    return attrStruct[READVALUE].value
                return attrStruct[READVALUE]
            return None

        def eventGeneratorThread(self):
            '''
            '''
            self.info_stream("Starting event generator thread")
            time.sleep(self._plcUpdatePeriod*2)
            #with in the start up procedure, if the device is running in local 
            #mode, it tries to lock the PLC control for itself by writting the 
            #Locking flag.
            if self._deviceIsInLocal:
                self.write_lock(True)
            while not self._tangoEventsJoiner.isSet():
                try:
                    start_t = time.time()
                    if self.has_data_available():
                        nEvents = self.plcGeneralAttrEvents()
                        nEvents += self.internalAttrEvents()
                        diff_t = time.time() - start_t
                        self._tangoEventsTime.append(diff_t)
                        self._tangoEventsNumber.append(nEvents)
                        self.debug_stream("eventGeneratorThread() "\
                                         "it has take %3.6f seconds for %d "\
                                         "events"
                                         %(diff_t,nEvents))
                        #TODO: collect this pairs (diff,nEvents) for statistics
                        if diff_t <= EVENT_THREAD_PERIOD:
                            time.sleep(EVENT_THREAD_PERIOD-diff_t)
                    else:
                        time.sleep(self.ReconnectWait)
                        #self.reconnect()
                except Exception,e:
                    self.error_stream("In eventGeneratorThread() "\
                                      "exception: %s"%(e))

        def __lastEventHasChangingQuality(self,attrName):
            attrStruct = self._getAttrStruct(attrName)
            if attrStruct.has_key(MEANINGS) or attrStruct.has_key(ISRESET):
                #To these attributes this doesn't apply
                return False
            if attrStruct.has_key(LASTEVENTQUALITY):
                if attrStruct[LASTEVENTQUALITY] == \
                                             PyTango.AttrQuality.ATTR_CHANGING:
                    return True
                else:
                    return False
            else:
                return False
            
        def __attrValueHasThreshold(self,attrName):
            if self._getAttrStruct(attrName).has_key(EVENTS) and \
               self._getAttrStruct(attrName)[EVENTS].has_key(THRESHOLD):
                return True
            else:
                return False

        def __isRstAttr(self,attrName):
            if attrName.startswith('lastUpdate'):
                return False
            if self._getAttrStruct(attrName).has_key(ISRESET):
                return self._getAttrStruct(attrName)[ISRESET]
            else:
                return False

        def __checkAttrEmissionParams(self,attrName,newValue):
            if not self.__attrHasEvents(attrName):
                self.warn_stream("No events for the attribute %s"%(attrName))
                return False
            lastValue = self.__getAttrReadValue(attrName)
#            self.debug_stream("Attribute '%s' last value '%s' new value '%s'"
#                              %(attrName,str(lastValue),str(newValue)))
            if lastValue == None:
                #If there is no previous read, it has to be emitted
                return True
            #after that we know the values are different
            if self.__isRstAttr(attrName):
                writeValue = self._getAttrStruct(attrName)[WRITEVALUE]
                rst_t = self._getAttrStruct(attrName)[RESETTIME]
                if newValue == True and lastValue == False and\
                   writeValue == True and rst_t != None:
                    return True
                elif newValue == False and lastValue == True and\
                   writeValue == False and rst_t == None:
                    return True
                else:
                    return False
            if self.__attrValueHasThreshold(attrName):
                diff = abs(lastValue - newValue)
                threshold = self._getAttrStruct(attrName)[EVENTS][THRESHOLD]
                if diff > threshold:
                    return True
                elif self.__lastEventHasChangingQuality(attrName):
                    #below the threshold and last quality changing is an 
                    #indicative that a movement has finish, then it's time
                    #to emit an event with a quality valid.
                    return True
                else:
                    return False
            #At this point any special case has been treated, only avoid
            #to emit if value doesn't change
            if newValue != lastValue:
                return True
            #when non case before, no event
            return False

        def plcGeneralAttrEvents(self):
            '''This method is used to periodically loop to review the list of
               attribute (above the basics) and check if they need event 
               emission.
            '''
            now = time.time()
            attributeList = self._plcAttrs.keys()
            #remove the ones managed in plcBasicAttrEvents()
            if attributeList.count('HeartBeat'):
                attributeList.pop(attributeList.index('HeartBeat'))
            if attributeList.count('Lock_ST'):
                attributeList.pop(attributeList.index('Lock_ST'))
            if attributeList.count('Lock_Status'):
                attributeList.pop(attributeList.index('Lock_Status'))
            if attributeList.count('Locking'):
                attributeList.pop(attributeList.index('Locking'))
            #Iterate the remaining to know if they need something to be done
            attr2Event = []
            for attrName in attributeList:
                self.checkResetAttr(attrName)
                self.checkRampAttr(attrName)
                #First check if for this element, it's prepared for events
                if self.__attrHasEvents(attrName):
                    try:
                        attrStruct = self._getAttrStruct(attrName)
                        attrType = attrStruct[TYPE]
                        #lastValue = self.__getAttrReadValue(attrName)
                        last_read_t = attrStruct[READTIME]
                        if attrStruct.has_key(READADDR):
                            read_addr = attrStruct[READADDR]
                            if attrStruct.has_key(READBIT):
                                read_bit = attrStruct[READBIT]
                                newValue = self.read_db.bit(read_addr,
                                                            read_bit)
                            else:
                                newValue = self.read_db.get(read_addr,
                                                            *attrType)
                            if attrStruct.has_key(FORMULA) and \
                               attrStruct[FORMULA].has_key('read'):
                                newValue = self.__solveFormula(attrName,
                                                               newValue,
                                                 attrStruct[FORMULA]['read'])
                        if self.__checkAttrEmissionParams(attrName,newValue):
                            self.__applyReadValue(attrName,newValue,
                                                  self.last_update_time)
                            if attrStruct.has_key(MEANINGS):
                                attrValue = self.__buildAttrMeaning(\
                                                             attrName,newValue)
                                attrQuality = self.__buildAttrQuality(\
                                                             attrName,newValue)
                            elif attrStruct.has_key(QUALITIES):
                                attrValue = newValue
                                attrQuality = self.__buildAttrQuality(\
                                                            attrName,attrValue)
                            else:
                                attrValue = newValue
                                attrQuality = PyTango.AttrQuality.ATTR_VALID
                            #store the current quality to know an end of 
                            #a movement: quality from changing to valid
                            attrStruct[LASTEVENTQUALITY] = attrQuality
                            #collect to launch fire event
                            attr2Event.append([attrName,
                                                attrValue,
                                                attrQuality])
                            #FIXME: debug for ramping
                            if self.__isRampingAttr(attrName):
                                self.info_stream("EVENT for %s: read=%s "\
                                                 "write=%s"%(attrName,
                                             self.__getAttrReadValue(attrName),
                                                   attrStruct[WRITEVALUE]))
#                        else:
#                            if self.__isRampingAttr(attrName) and \
#                               not self.__isRampDone(attrName):
#                                self.info_stream("NO event for %s: read=%s "\
#                                                 "write=%s"%(attrName,
#                                             self.__getAttrReadValue(attrName),
#                                                   attrStruct[WRITEVALUE]))
                    except Exception,e:
                        self.warn_stream("In plcGeneralAttrEvents(), "\
                                          "exception in attribute %s: %s"
                                          %(attrName,e))
            if len(attr2Event) > 0:
                self.fireEventsList(attr2Event,log=True)
            return len(attr2Event)

        def internalAttrEvents(self):
            '''
            '''
            now = time.time()
            attributeList = self._internalAttrs.keys()
            attr2Event = []
            for attrName in attributeList:
                if self.__attrHasEvents(attrName):
                    try:
                        #evaluate if emition needed
                        #internal attr types:
                        # - logical
                        # - sets
                        attrStruct = self._getAttrStruct(attrName)
                        attrType = attrStruct[TYPE]
                        lastValue = self.__getAttrReadValue(attrName)
                        last_read_t = attrStruct[READTIME]
                        if attrStruct.has_key(LOGIC):
                            #self.info_stream("Attribute %s is from logical "\
                            #                 "type"%(attrName))
                            newValue = self._evalLogical(attrName)
                        elif attrStruct.has_key('read_set'):
                            #self.info_stream("Attribute %s is from group type"
                            #                 %(attrName))
                            newValue = self.__getGrpBitValue(attrName,
                                                       attrStruct['read_set'],
                                                       self.read_db)
                        else:
                            self.warn_stream("In internalAttrEvents(): "\
                                             "unknown how to emit events "\
                                             "for %s attribute"%(attrName))
                            newValue = lastValue
                        emit = False
                        if newValue != lastValue:
                            #self.info_stream("Emit because %s!=%s"
                            #                 %(str(newValue),str(lastValue)))
                            emit = True
                        elif (last_read_t == None):
                            #self.info_stream("Emit new value because it "\
                            #                 "wasn't read before")
                            emit = True
                        else:
                            pass
                            #self.info_stream("No event to emit "\
                            #                 "(lastValue %s (%s), "\
                            #                 "newValue %s)"
                            #                 %(str(lastValue),
                            #                   str(last_read_t),
                            #                   str(newValue)))
                    except Exception,e:
                        self.error_stream("In internalAttrEvents(), "\
                                          "exception reading attribute %s: %s"
                                          %(attrName,e))
                    else:
                        #prepare to emit
                        try:
                            if emit:
                                self.__applyReadValue(attrName,
                                                      newValue,
                                                      self.last_update_time)
                                if attrStruct.has_key(MEANINGS):
                                    attrValue = self.__buildAttrMeaning(\
                                                             attrName,newValue)
                                    attrQuality = self.__buildAttrQuality(\
                                                             attrName,newValue)
                                elif attrStruct.has_key(QUALITIES):
                                    attrValue = newValue
                                    attrQuality = self.__buildAttrQuality(\
                                                            attrName,attrValue)
                                else:
                                    attrValue = newValue
                                    attrQuality=PyTango.AttrQuality.ATTR_VALID
                                attr2Event.append([attrName,attrValue])
                        except Exception,e:
                            self.error_stream("In internalAttrEvents(), "\
                                              "exception on emit attribute "\
                                              "%s: %s"%(attrName,e))
            if len(attr2Event) > 0:
                self.fireEventsList(attr2Event,log=True)
            return len(attr2Event)

        def checkResetAttr(self,attrName):
            '''
            '''
            if not self.__isRstAttr(attrName):
                return
            #FIXME: if this is moved to a new thread separated to the event 
            #       emission, the system must be changed to be pasive waiting
            #       (that it Threading.Event())
            if self.__isCleanResetNeed(attrName):
                self._plcAttrs[attrName][RESETTIME] = None
                readAddr = self._plcAttrs[attrName][READADDR]
                writeAddr = self._plcAttrs[attrName][WRITEADDR]
                writeBit = self._plcAttrs[attrName][WRITEBIT]
                writeValue = False
                self.__writeBit(attrName,readAddr,
                                writeAddr,writeBit,writeValue)
                self._plcAttrs[attrName][WRITEVALUE] = writeValue
                self.info_stream("Set back to 0 a RST attr %s"%(attrName))
                #self._plcAttrs[attrName][READVALUE] = False
                #self.fireEvent([attrName,False],time.time())

        def __isCleanResetNeed(self,attrName):
            '''
            '''
            now = time.time()
            if self.__isResetAttr(attrName):
                read_value = self._plcAttrs[attrName][READVALUE]
                rst_t = self._plcAttrs[attrName][RESETTIME]
                if read_value and not rst_t == None:
                    diff_t = now-rst_t
                    if self._plcAttrs[attrName].has_key(RESETACTIVE):
                        activeRst_t = self._plcAttrs[attrName][RESETACTIVE]
                    else:
                        activeRst_t = ACTIVE_RESET_T
                    if activeRst_t-diff_t < 0:
                        self.info_stream("Attribute %s needs clean reset"
                                         %(attrName))
                        return True
                    self.info_stream("Do not clean reset flag yet for %s "\
                                     "(%6.3f seconds left)"
                                     %(attrName,activeRst_t-diff_t))
            return False

        def __isResetAttr(self,attrName):
            '''
            '''
            if self._plcAttrs.has_key(attrName) and\
               self._plcAttrs[attrName].has_key(ISRESET) and \
               self._plcAttrs[attrName][ISRESET] == True:
                return True
            return False

        def checkRampAttr(self,attrName):
            '''Given a plc attribute, this method check if it has the ramp
               feature. If it's the case, it will check if any of the user
               attributes has change to update the main dictionary structure.
            '''
            if not self.__isRampAttr(attrName):
                return
            attrStruct = self._getAttrStruct(attrName)
            for rampDirection in attrStruct[RAMP].keys():
                for subAttrName in attrStruct[RAMP][rampDirection].keys():
                    if subAttrName in [STEP,STEPTIME,THRESHOLD]:
                        subAttrStruct= self._getAttrStruct(attrName+'_'+\
                                                           rampDirection+'_'+\
                                                           subAttrName)
                        attrStruct[RAMP][rampDirection][subAttrName] = \
                                                    subAttrStruct[READVALUE]
#                    elif subAttrName in [SWITCH]:
#                        #TODO: check if there has been any power on or off
#                        #      transition that requires a thread launch to 
#                        #      manage it.
#                        if attrStruct[RAMP][rampDirection][subAttrName]\
#                                                          .has_key(WHENOFF):
#                            subAttrStruct = self._getAttrStruct(attrName+'_'+\
#                                                           rampDirection+'_'+\
#                                                           WHENOFF)
#                            attrStruct[RAMP][rampDirection][subAttrName] = \
#                                                    subAttrStruct[READVALUE]
        
        def __isRampAttr(self,attrName):
            attrStruct = self._getAttrStruct(attrName)
            if attrStruct.has_key(RAMP):
                return True
            return False

        def relock(self):
            '''
            '''
            if self._plcAttrs['Locking'][WRITEVALUE] == True:
                self.write_lock(True)
        #---- end "To be moved" section

        def plcUpdaterThread(self):
            '''
            '''
            #self.info_stream("Starting plc updater thread")
            time.sleep(self._plcUpdatePeriod)
            while not self._plcUpdateJoiner.isSet():
                try:
                    start_t = time.time()
                    if self.is_connected():
                        self.readPlcRegisters()
                        diff_t = time.time() - start_t
                        if diff_t > EXPECTED_UPDATE_TIME:
                            if self._plcUpdatePeriod < PLC_MAX_UPDATE_PERIOD:
                                self.warn_stream("plcUpdaterThread() "\
                                                 "it has take %3.6f seconds, "\
                                                 "more than expected, "\
                                                 "increase period (%3.3f + "\
                                                 "%3.3f seconds)"
                                                 %(diff_t,
                                                   self._plcUpdatePeriod,
                                                   10*PLC_STEP_UPDATE_PERIOD))
                                self._plcUpdatePeriod += \
                                                      10*PLC_STEP_UPDATE_PERIOD
                            else:
                                self.error_stream("plcUpdaterThread() "\
                                                  "it has take %3.6f seconds,"\
                                                  " more than expected and "\
                                                  "period cannot be increased"\
                                                  " (%3.3f seconds)"
                                                  %(diff_t,
                                                    self._plcUpdatePeriod))
                        elif diff_t > self._plcUpdatePeriod:
                            self.warn_stream("plcUpdaterThread() has take "\
                                             "too much time (%3.3f seconds)"
                                             %(diff_t))
                            if self._plcUpdatePeriod < PLC_MAX_UPDATE_PERIOD:
                                self._plcUpdatePeriod += \
                                                      10*PLC_STEP_UPDATE_PERIOD
                        else:
                            self.debug_stream("plcUpdaterThread() "\
                                              "it has take %3.6f seconds, "\
                                              "going to sleep %3.3f seconds "\
                                              "(update period %3.3f seconds)"
                                              %(diff_t,
                                              self._plcUpdatePeriod-diff_t,
                                              self._plcUpdatePeriod))
                            time.sleep(self._plcUpdatePeriod-diff_t)
                    else:
                        if self._plcUpdateJoiner.isSet():
                            return
                        self.info_stream('plc not connected')
                        self.reconnect()
                        time.sleep(self.ReconnectWait)
                except Exception,e:
                    self.error_stream("In plcUpdaterThread() "\
                                      "exception: %s"%(e))
                    traceback.print_exc()

        @CommandExc
        def Update(self):
            '''Deprecated
            '''
            pass

        def readPlcRegisters(self):
            """ Do a read of all the registers in the plc and update the 
                mirrored memory
            
            :param argin: 
            :type: PyTango.DevVoid
            :return: 
            :rtype: PyTango.DevVoid """
            
            #----- PROTECTED REGION ID(LinacData.Update) ENABLED START -----#
            # faults are critical and can not be recovered by restarting things
            # INIT states mean something is going is on that interferes with
            #      updating, such as connecting
            start_update_time = time.time()
            if (self.get_state()==PyTango.DevState.FAULT) or \
                                                     (not self.is_connected()):
                if start_update_time-self.last_update_time<self.ReconnectWait:
                    return
                else:
                    if self.connect():
                        self.set_state(PyTango.DevState.UNKNOWN)
                    return
            #---- relock if auto-recover from fault
            if self._deviceIsInLocal and self._plcAttrs.has_key('Locking') \
               and self._plcAttrs['Locking'][READVALUE] == False:
                self.relock()
            try:
                up = self.read_db.readall()#The real reading to the hardware
                if up:
                    self.last_update_time = time.time()
                    self.check_lock()
                    self.plcBasicAttrEvents()
                    if not self.get_state() in [PyTango.DevState.ON]:
                        self.set_state(PyTango.DevState.ON)
                else:
                    self.set_state(PyTango.DevState.FAULT)
                    self.set_status("No data received from the PLC")
                end_update_t = time.time()
                diff_t = (end_update_t - start_update_time)
                if end_update_t-self.last_update_time > self.TimeoutAlarm:
                    self.set_state(PyTango.DevState.ALARM)
                    self.set_status("Timeout alarm!"%())
                    return
                # disconnect if no new information is send after long time
                if end_update_t-self.last_update_time > self.TimeoutConnection:
                    self.disconnect()
                    self.set_state(PyTango.DevState.FAULT)
                    self.set_status("Timeout connection!"%())
                    return
                self.read_lastUpdate_attr = diff_t
                timeFormated = time.strftime('%F %T')
                self.read_lastUpdateStatus_attr = "last updated at %s in %f s"\
                                                  %(timeFormated,diff_t)
                attr2Event = [['lastUpdate',self.read_lastUpdate_attr],
                          ['lastUpdateStatus',self.read_lastUpdateStatus_attr]]
                self.fireEventsList(attr2Event)
#                self.info_stream("Update() it has take %3.6f seconds"
#                                 %(diff_t))
                #---- when an update goes fine, the period is reduced one step
                #     until the minumum
                if self._plcUpdatePeriod > PLC_MIN_UPDATE_PERIOD:
                    self._plcUpdatePeriod -= PLC_STEP_UPDATE_PERIOD
            except tcpblock.Shutdown, exc:
                self.set_state(PyTango.DevState.FAULT)
                msg = 'communication shutdown requested '\
                      'at '+time.strftime('%F %T')
                self.set_status(msg)
                self.error_stream(msg)
                self.disconnect()
            except socket.error, exc:
                self.set_state(PyTango.DevState.FAULT)
                msg = 'broken socket at %s\n%s'%(time.strftime('%F %T'),
                                                 str(exc))
                self.set_status(msg)
                self.error_stream(msg)
                self.disconnect()
            except Exception, exc:
                self.set_state(PyTango.DevState.FAULT)
                msg = 'update failed at %s\n%s: %s'%(time.strftime('%F %T'),
                                                     str(type(exc)),str(exc))
                self.set_status(msg)
                self.error_stream(msg)
                self.disconnect()
                self.last_update_time = time.time()
                traceback.print_exc()
            #----- PROTECTED REGION END -----#    //    LinacData.Update



#==================================================================
#
#       LinacDataClass class definition
#
#==================================================================
class LinacDataClass(PyTango.DeviceClass):
        #--------- Add you global class variables here --------------------------
        #----- PROTECTED REGION ID(LinacData.global_class_variables) ENABLED START -----#
        
        #----- PROTECTED REGION END -----#    //    LinacData.global_class_variables
        
        def dyn_attr(self, dev_list):
            """Invoked to create dynamic attributes for the given devices.
            Default implementation calls
            :meth:`LinacData.initialize_dynamic_attributes` for each device
        
            :param dev_list: list of devices
            :type dev_list: :class:`PyTango.DeviceImpl`"""
        
            for dev in dev_list:
                try:
                    dev.initialize_dynamic_attributes()
                except:
                    dev.warn_stream("Failed to initialize dynamic attributes")
                    dev.debug_stream("Details: " + traceback.format_exc())
            #----- PROTECTED REGION ID(LinacData.dyn_attr) ENABLED START -----#
            
            #----- PROTECTED REGION END -----#    //    LinacData.dyn_attr

        #    Class Properties
        class_property_list = {
            }

        #    Device Properties
        device_property_list = {
                'ReadSize':
                        [PyTango.DevShort,
                        "how many bytes to read (should be a multiple of 2)", 0
                         ],
                'WriteSize':
                        [PyTango.DevShort,
                        "size of write data block",
                        0],
                'IpAddress':
                        [PyTango.DevString,
                        "ipaddress of linac PLC (deprecated)",
                        ''],
                'PlcAddress':
                        [PyTango.DevString,
                        "ipaddress of linac PLC",
                        ''],
                'Port':
                        [PyTango.DevShort,
                        "port of linac PLC (deprecated)",
                        None],
                'LocalPort':
                        [PyTango.DevShort,
                        "port of linac PLC (deprecated)",
                        None],
                'RemotePort':
                        [PyTango.DevShort,
                        "port of linac PLC (deprecated)",
                        None],

                'AttrFile':
                        [PyTango.DevString,
                        'file that contains description of attributes of this '\
                        'Linac data block',
                        ''],

                'BindAddress':
                        [PyTango.DevString,
                        'ip of the interface used to communicate with plc (deprecated)',
                        ''],

                'LocalAddress':
                        [PyTango.DevString,
                        'ip of the interface used to communicate with plc as the local',
                        '10.0.7.100'],

                'RemoteAddress':
                        [PyTango.DevString,
                        'ip of the interface used to communicate with plc as the remote',
                         '10.0.7.1'],

                'TimeoutAlarm':
                        [PyTango.DevDouble,
                        "after how many seconds of silence the state is set "\
                        "to alarm, this should be less than TimeoutConnection",
                        1.0],

                'TimeoutConnection':
                        [PyTango.DevDouble,
                        "after how many seconds of silence the connection is "\
                        "assumed to be interrupted",
                        1.5],

                'ReconnectWait':
                        [PyTango.DevDouble,
                        "after how many seconds since the last update the "\
                        "next connection attempt is made",
                        6.0],
        }
        class_property_list['TimeoutAlarm'] = device_property_list['TimeoutAlarm']
        class_property_list['TimeoutConnection'] = device_property_list['TimeoutConnection']
        class_property_list['ReconnectWait'] = device_property_list['ReconnectWait']


        #    Command definitions
        cmd_list = {
                'ReloadAttrFile':
                        [[PyTango.DevVoid, ""],
                        [PyTango.DevVoid, ""]],
                'Exec':
                        [[PyTango.DevString, "statement to executed"],
                        [PyTango.DevString, "result"],
                        {'Display level':PyTango.DispLevel.EXPERT,}],
                'GetBit':
                        [[PyTango.DevVarShortArray, "idx"],
                        [PyTango.DevBoolean, ""],
                        {'Display level':PyTango.DispLevel.EXPERT,}],
                'GetByte':
                        [[PyTango.DevShort, "idx"],
                        [PyTango.DevShort, ""],
                        {'Display level':PyTango.DispLevel.EXPERT,}],
                'GetShort':
                        [[PyTango.DevShort, "idx"],
                        [PyTango.DevShort, ""],
                        {'Display level':PyTango.DispLevel.EXPERT,}],
                'GetFloat':
                        [[PyTango.DevShort, "idx"],
                        [PyTango.DevFloat, ""],
                        {'Display level':PyTango.DispLevel.EXPERT,}],
                'HexDump':
                        [[PyTango.DevVoid, "idx"],
                        [PyTango.DevString, "hexdump of all data"]],
                'Hex':
                        [[PyTango.DevShort, "idx"],
                        [PyTango.DevString, ""]],
                'DumpTo':
                        [[PyTango.DevString, "target file"],
                        [PyTango.DevVoid, ""],
                        {} ],
                'WriteBit':
                        [[PyTango.DevVarShortArray, "idx, bitno, value"],
                        [PyTango.DevVoid, ""],
                        {'Display level':PyTango.DispLevel.EXPERT,}],
                'WriteByte':
                        [[PyTango.DevVarShortArray, "idx, value"],
                        [PyTango.DevVoid, ""],
                        {'Display level':PyTango.DispLevel.EXPERT,}],
                'WriteShort':
                        [[PyTango.DevVarShortArray, "idx, value"],
                        [PyTango.DevVoid, ""],
                        {'Display level':PyTango.DispLevel.EXPERT,}],
                'WriteFloat':
                        [[PyTango.DevVarFloatArray, "idx, value"],
                        [PyTango.DevVoid, ""],
                        {'Display level':PyTango.DispLevel.EXPERT,}],
                'ResetState':
                        [[PyTango.DevVoid, ""],
                        [PyTango.DevVoid, ""]],
                'Update':
                        [[PyTango.DevVoid, ""],
                        [PyTango.DevVoid, ""],
                        #{ 'polling period' : 50 }
                        ],
                }

        #    Attribute definitions
        attr_list = {
            'EventsTime':
                [[PyTango.DevDouble,
                  PyTango.SPECTRUM,
                  PyTango.READ, 1000],
                 {
                  'Display level': PyTango.DispLevel.EXPERT,
                 }
                ],
            'EventsNumber':
                [[PyTango.DevShort,
                  PyTango.SPECTRUM,
                  PyTango.READ, 1000],
                 {
                  'Display level': PyTango.DispLevel.EXPERT,
                 }
                ],
        }

if __name__ == '__main__':
        try:
            py = PyTango.Util(sys.argv)
            py.add_TgClass(LinacDataClass,LinacData,'LinacData')
    
            U = PyTango.Util.instance()
            U.server_init()
            U.server_run()

        except PyTango.DevFailed,e:
            PyTango.Except.print_exception(e)
        except Exception,e:
            traceback.print_exc()

